# AiCarpool ä¼ä¸šçº§äº§å“éœ€æ±‚æ–‡æ¡£ (PRD)

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| **äº§å“åç§°** | AiCarpool - AIç¼–ç¨‹å·¥å…·æ‹¼è½¦æœåŠ¡å¹³å° |
| **ç‰ˆæœ¬** | v2.0 (ä¼ä¸šçº§) |
| **æ–‡æ¡£ç‰ˆæœ¬** | 1.0 |
| **åˆ›å»ºæ—¶é—´** | 2025-08-01 |
| **è´Ÿè´£äºº** | coso |
| **çŠ¶æ€** | éœ€æ±‚åˆ†æ |

---

## ğŸ¯ äº§å“æ¦‚è¿°

### äº§å“å®šä½
AiCarpool æ˜¯ä¸€ä¸ª**é€šç”¨åŒ–çš„AIèµ„æºç®¡ç†å¹³å°**ï¼Œé€šè¿‡åˆ›æ–°çš„"è´¦å·æ± +æ‹¼è½¦ç»„"åŒä½“ç³»è®¾è®¡ï¼Œå®ç°ä»å°å›¢é˜Ÿåˆ°ä¼ä¸šçº§çš„AIç¼–ç¨‹å·¥å…·èµ„æºç»Ÿä¸€ç®¡ç†ã€æ™ºèƒ½åˆ†é…å’Œæˆæœ¬ä¼˜åŒ–ã€‚

### æ ¸å¿ƒä»·å€¼ä¸»å¼ 
- **é€šç”¨æ€§**ï¼šåŒæ—¶æ»¡è¶³å°å›¢é˜Ÿç‰©ç†éš”ç¦»å’Œä¼ä¸šçº§èµ„æºå…±äº«éœ€æ±‚
- **çµæ´»æ€§**ï¼šæ”¯æŒå¤šç§è´¦å·ç»‘å®šå’Œåˆ†é…ç­–ç•¥
- **ç»æµæ€§**ï¼šæœ€å¤§åŒ–AIè´¦å·åˆ©ç”¨ç‡ï¼Œé™ä½ä¼ä¸šAIä½¿ç”¨æˆæœ¬
- **å¯æ§æ€§**ï¼šç²¾ç»†åŒ–çš„æƒé™ç®¡ç†å’Œä½¿ç”¨é™é¢æ§åˆ¶

### ç›®æ ‡å¸‚åœº
1. **å°å‹å›¢é˜Ÿ** (3-10äºº)ï¼šéœ€è¦è´¦å·ç‰©ç†éš”ç¦»çš„å¼€å‘å›¢é˜Ÿ
2. **ä¸­å‹ä¼ä¸š** (50-200äºº)ï¼šéœ€è¦éƒ¨é—¨çº§èµ„æºç®¡ç†çš„å…¬å¸
3. **å¤§å‹ä¼ä¸š** (200+äºº)ï¼šéœ€è¦ä¼ä¸šçº§AIèµ„æºç»Ÿä¸€ç®¡ç†çš„ç»„ç»‡

---

## ğŸ‘¥ ç”¨æˆ·è§’è‰²ä¸åœºæ™¯

### æ ¸å¿ƒç”¨æˆ·è§’è‰²

#### 1. ä¼ä¸šç®¡ç†å‘˜
- **èŒè´£**ï¼šä¼ä¸šçº§AIèµ„æºç»Ÿç­¹ç®¡ç†
- **æƒé™**ï¼šè´¦å·æ± ç®¡ç†ã€ç»„ç»‡æ¶æ„é…ç½®ã€å…¨å±€ç›‘æ§
- **å…³æ³¨ç‚¹**ï¼šæˆæœ¬æ§åˆ¶ã€èµ„æºåˆ©ç”¨ç‡ã€å®‰å…¨åˆè§„

#### 2. éƒ¨é—¨ç®¡ç†å‘˜  
- **èŒè´£**ï¼šéƒ¨é—¨å†…AIèµ„æºåˆ†é…å’Œç®¡ç†
- **æƒé™**ï¼šæ‹¼è½¦ç»„ç®¡ç†ã€æˆå‘˜æƒé™æ§åˆ¶ã€éƒ¨é—¨ç»Ÿè®¡
- **å…³æ³¨ç‚¹**ï¼šå›¢é˜Ÿæ•ˆç‡ã€é¢„ç®—æ§åˆ¶ã€ä½¿ç”¨ç»Ÿè®¡

#### 3. æ™®é€šç”¨æˆ·
- **èŒè´£**ï¼šæ—¥å¸¸AIç¼–ç¨‹å·¥å…·ä½¿ç”¨
- **æƒé™**ï¼šåŸºç¡€ä½¿ç”¨åŠŸèƒ½ã€ä¸ªäººç»Ÿè®¡æŸ¥çœ‹
- **å…³æ³¨ç‚¹**ï¼šä½¿ç”¨ä¾¿æ·æ€§ã€å“åº”é€Ÿåº¦ã€åŠŸèƒ½ç¨³å®šæ€§

### å…¸å‹ä½¿ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šè€ç”˜çš„å°å›¢é˜Ÿåœºæ™¯
**èƒŒæ™¯**ï¼šè€ç”˜è¿è¥ä¸€ä¸ª10äººçš„å¼€å‘å›¢é˜Ÿï¼Œéœ€è¦ä¸ºæ¯ä¸ªé¡¹ç›®ç»„æä¾›ç‹¬ç«‹çš„AIè´¦å·ã€‚

**éœ€æ±‚**ï¼š
- ç‰©ç†éš”ç¦»ï¼šæ¯ä¸ªæ‹¼è½¦ç»„ç»‘å®šä¸“å±è´¦å·
- æˆæœ¬åˆ†æ‘Šï¼šæŒ‰ä½¿ç”¨é‡ç²¾ç¡®è®¡è´¹
- ç®€å•ç®¡ç†ï¼šæ˜“äºé…ç½®å’Œç»´æŠ¤

**è§£å†³æ–¹æ¡ˆ**ï¼š
```
æ‹¼è½¦ç»„A â†â†’ ä¸“å±è´¦å·1 (Claude Pro)
æ‹¼è½¦ç»„B â†â†’ ä¸“å±è´¦å·2 (Gemini Advanced)  
æ‹¼è½¦ç»„C â†â†’ ä¸“å±è´¦å·3 (Claude Pro)
```

#### åœºæ™¯2ï¼šæ— è¶£çš„ä¼ä¸šåœºæ™¯
**èƒŒæ™¯**ï¼š100äººçš„è½¯ä»¶å…¬å¸ï¼Œå¸Œæœ›æœ€å¤§åŒ–AIè´¦å·åˆ©ç”¨ç‡ï¼ŒåŒæ—¶æ»¡è¶³è¡Œæ”¿ç®¡ç†éœ€æ±‚ã€‚

**éœ€æ±‚**ï¼š
- èµ„æºå…±äº«ï¼šå¤šä¸ªéƒ¨é—¨å…±ç”¨è´¦å·æ± 
- è´Ÿè½½å‡è¡¡ï¼šæ™ºèƒ½åˆ†é…é¿å…è´¦å·è¿‡è½½
- æˆæœ¬åˆ†æ‘Šï¼šæŒ‰éƒ¨é—¨ç»Ÿè®¡å’Œåˆ†æ‘Šè´¹ç”¨
- é¢„ç®—æ§åˆ¶ï¼šä¸ºå„éƒ¨é—¨è®¾ç½®ä½¿ç”¨ä¸Šé™

**è§£å†³æ–¹æ¡ˆ**ï¼š
```
å…±äº«è´¦å·æ±  [è´¦å·1, è´¦å·2, è´¦å·3, è´¦å·4, è´¦å·5]
    â†“ æ™ºèƒ½åˆ†é…
å‰ç«¯ç»„ (20äºº) â†â†’ å…±äº«æ±  + ä¸“å±è´¦å·A
åç«¯ç»„ (30äºº) â†â†’ å…±äº«æ±  + ä¸“å±è´¦å·B  
æµ‹è¯•ç»„ (15äºº) â†â†’ å…±äº«æ± 
äº§å“ç»„ (10äºº) â†â†’ å…±äº«æ± 
```

#### åœºæ™¯3ï¼šæ··åˆåœºæ™¯
**èƒŒæ™¯**ï¼šæŸç§‘æŠ€å…¬å¸ï¼Œå¤§éƒ¨åˆ†å›¢é˜Ÿå…±äº«èµ„æºï¼Œæ ¸å¿ƒä¸šåŠ¡å›¢é˜Ÿéœ€è¦ä¸“å±è´¦å·ã€‚

**éœ€æ±‚**ï¼š
- åˆ†å±‚ç®¡ç†ï¼šæ ¸å¿ƒå›¢é˜Ÿä¸“å±ï¼Œæ™®é€šå›¢é˜Ÿå…±äº«
- å¼¹æ€§æ‰©å±•ï¼šæ ¹æ®ä¸šåŠ¡éœ€è¦çµæ´»è°ƒæ•´
- æˆæœ¬ä¼˜åŒ–ï¼šåœ¨ä¿è¯æ ¸å¿ƒä¸šåŠ¡çš„å‰æä¸‹æœ€å¤§åŒ–åˆ©ç”¨ç‡

**è§£å†³æ–¹æ¡ˆ**ï¼š
```
æ ¸å¿ƒä¸šåŠ¡ç»„ â†â†’ ä¸“å±é«˜çº§è´¦å·æ± 
ç ”å‘éƒ¨é—¨ â†â†’ å…±äº«æ ‡å‡†è´¦å·æ±   
æ”¯æŒéƒ¨é—¨ â†â†’ å…±äº«åŸºç¡€è´¦å·æ± 
```

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½è®¾è®¡

### 1. è´¦å·æ± ç®¡ç†ç³»ç»Ÿ

#### 1.1 è´¦å·æ± æ¦‚å¿µ
**è´¦å·æ± **æ˜¯AIæœåŠ¡è´¦å·çš„é€»è¾‘é›†åˆï¼Œæ”¯æŒä»¥ä¸‹å±æ€§ï¼š

```json
{
  "poolId": "pool_001",
  "name": "ä¼ä¸šå…±äº«æ± ",
  "type": "shared|dedicated", 
  "accounts": ["account_1", "account_2", "account_3"],
  "loadBalanceStrategy": "round_robin|least_connections|weighted",
  "maxLoadPerAccount": 80, // å•è´¦å·æœ€å¤§è´Ÿè½½ç™¾åˆ†æ¯”
  "priority": 1, // æ± ä¼˜å…ˆçº§
  "isActive": true
}
```

#### 1.2 è´¦å·æ ‡ç­¾ç³»ç»Ÿ
- **å…±äº«æ ‡ç­¾**ï¼š`shared` - å¯è¢«å¤šä¸ªæ‹¼è½¦ç»„ä½¿ç”¨
- **ä¸“å±æ ‡ç­¾**ï¼š`dedicated` - ä»…æœåŠ¡ç‰¹å®šæ‹¼è½¦ç»„
- **ä¼˜å…ˆçº§æ ‡ç­¾**ï¼š`high|medium|low` - å½±å“åˆ†é…ä¼˜å…ˆçº§
- **æœåŠ¡ç±»å‹æ ‡ç­¾**ï¼š`claude|gemini|copilot` - æŒ‰AIæœåŠ¡åˆ†ç±»

#### 1.3 è´Ÿè½½å‡è¡¡ç­–ç•¥
1. **è½®è¯¢åˆ†é…** (Round Robin)ï¼šä¾æ¬¡åˆ†é…è¯·æ±‚
2. **æœ€å°‘è¿æ¥** (Least Connections)ï¼šåˆ†é…ç»™å½“å‰è´Ÿè½½æœ€ä½çš„è´¦å·
3. **åŠ æƒåˆ†é…** (Weighted)ï¼šæ ¹æ®è´¦å·æ€§èƒ½è®¾ç½®æƒé‡
4. **å¥åº·æ£€æŸ¥**ï¼šè‡ªåŠ¨å‰”é™¤ä¸å¯ç”¨è´¦å·

### 2. æ‹¼è½¦ç»„ç»‘å®šæœºåˆ¶

#### 2.1 çµæ´»ç»‘å®šå…³ç³»
æ”¯æŒä¸€å¯¹å¤šå’Œå¤šå¯¹å¤šçš„ç»‘å®šå…³ç³»ï¼š

```sql
-- æ‹¼è½¦ç»„å¯ä»¥ç»‘å®šå¤šä¸ªè´¦å·æ± 
group_pool_bindings (
  group_id, 
  pool_id, 
  binding_type, -- 'primary' | 'fallback' | 'shared'
  usage_limit,  -- è¯¥ç»„åœ¨æ­¤æ± çš„ä½¿ç”¨ä¸Šé™
  priority      -- ä½¿ç”¨ä¼˜å…ˆçº§
)

-- æ‹¼è½¦ç»„ä¹Ÿå¯ä»¥ç›´æ¥ç»‘å®šç‰¹å®šè´¦å·
group_account_bindings (
  group_id,
  account_id,
  binding_type, -- 'exclusive' | 'shared'
  usage_limit
)
```

#### 2.2 ä½¿ç”¨é™é¢æ§åˆ¶
- **æ± çº§åˆ«é™é¢**ï¼šæ‹¼è½¦ç»„åœ¨è´¦å·æ± ä¸­çš„ä½¿ç”¨ä¸Šé™
- **è´¦å·çº§åˆ«é™é¢**ï¼šæ‹¼è½¦ç»„å¯¹ç‰¹å®šè´¦å·çš„ä½¿ç”¨ä¸Šé™  
- **æ—¶é—´æ®µé™é¢**ï¼šæŒ‰å°æ—¶/æ—¥/æœˆè®¾ç½®ä½¿ç”¨é™åˆ¶
- **åŠ¨æ€è°ƒæ•´**ï¼šæ ¹æ®è´Ÿè½½æƒ…å†µåŠ¨æ€è°ƒæ•´é™é¢

#### 2.3 æ™ºèƒ½åˆ†é…ç®—æ³•
```typescript
interface AccountAllocationRequest {
  groupId: string;
  serviceType: 'claude' | 'gemini' | 'copilot';
  estimatedTokens?: number;
  priority?: 'high' | 'normal' | 'low';
}

interface AccountPool {
  id: string;
  name: string;
  type: 'shared' | 'dedicated';
  loadBalanceStrategy: 'round_robin' | 'least_connections' | 'weighted';
  accounts: AiServiceAccount[];
  maxLoadPerAccount: number;
  priority: number;
}

class EnterpriseAccountAllocator {
  constructor(private prisma: PrismaClient, private cache: CacheManager) {}

  async allocateAccount(request: AccountAllocationRequest): Promise<AiServiceAccount | null> {
    // 1. è·å–æ‹¼è½¦ç»„ç»‘å®šçš„è´¦å·æ± 
    const pools = await this.getGroupPools(request.groupId);
    
    // 2. æŒ‰ä¼˜å…ˆçº§æ’åºæ± 
    const sortedPools = pools.sort((a, b) => a.priority - b.priority);
    
    // 3. éå†æ± ï¼Œå¯»æ‰¾å¯ç”¨è´¦å·
    for (const pool of sortedPools) {
      // æ£€æŸ¥ä½¿ç”¨é™é¢
      if (await this.checkUsageLimit(request.groupId, pool.id)) {
        // æ ¹æ®è´Ÿè½½å‡è¡¡ç­–ç•¥é€‰æ‹©è´¦å·
        const account = await this.selectAccount(pool, request);
        if (account && await this.isAccountHealthy(account.id)) {
          return account;
        }
      }
    }
    
    // 4. å¦‚æœæ²¡æœ‰å¯ç”¨è´¦å·ï¼Œè¿”å›nullæˆ–åŠ å…¥ç­‰å¾…é˜Ÿåˆ—
    return await this.handleNoAvailableAccount(request);
  }

  private async getGroupPools(groupId: string): Promise<AccountPool[]> {
    return await this.cache.getOrSet(
      `group:pools:${groupId}`,
      async () => {
        return await this.prisma.groupPoolBinding.findMany({
          where: { groupId, isActive: true },
          include: {
            pool: {
              include: {
                accounts: {
                  where: { isActive: true },
                  include: { account: true }
                }
              }
            }
          },
          orderBy: { priority: 'asc' }
        });
      },
      { ttl: 300 } // 5åˆ†é’Ÿç¼“å­˜
    );
  }

  private async selectAccount(
    pool: AccountPool, 
    request: AccountAllocationRequest
  ): Promise<AiServiceAccount | null> {
    const availableAccounts = pool.accounts.filter(account => 
      account.serviceType === request.serviceType &&
      account.isActive &&
      this.getCurrentLoad(account.id) < pool.maxLoadPerAccount
    );

    if (availableAccounts.length === 0) return null;

    switch (pool.loadBalanceStrategy) {
      case 'round_robin':
        return this.roundRobinSelection(pool.id, availableAccounts);
      case 'least_connections':
        return this.leastConnectionsSelection(availableAccounts);
      case 'weighted':
        return this.weightedSelection(availableAccounts);
      default:
        return availableAccounts[0];
    }
  }
}
```

### 3. ä¼ä¸šçº§ç®¡ç†åŠŸèƒ½

#### 3.1 ç»„ç»‡æ¶æ„ç®¡ç†
```json
{
  "enterprise": {
    "id": "ent_001",
    "name": "æŸç§‘æŠ€å…¬å¸",
    "departments": [
      {
        "id": "dept_001", 
        "name": "ç ”å‘éƒ¨",
        "parent_id": null,
        "budget_limit": 10000,
        "groups": ["group_001", "group_002"]
      },
      {
        "id": "dept_002",
        "name": "å‰ç«¯ç»„", 
        "parent_id": "dept_001",
        "budget_limit": 3000,
        "groups": ["group_003"]
      }
    ]
  }
}
```

#### 3.2 æˆæœ¬åˆ†æ‘Šç³»ç»Ÿ
- **ä½¿ç”¨é‡ç»Ÿè®¡**ï¼šç²¾ç¡®è®°å½•æ¯ä¸ªè¯·æ±‚çš„tokenä½¿ç”¨é‡å’Œæˆæœ¬
- **åˆ†æ‘Šè§„åˆ™**ï¼šæ”¯æŒæŒ‰ä½¿ç”¨é‡ã€å›ºå®šåˆ†æ‘Šã€åŠ æƒåˆ†æ‘Šç­‰å¤šç§æ¨¡å¼
- **é¢„ç®—æ§åˆ¶**ï¼šå®æ—¶ç›‘æ§é¢„ç®—ä½¿ç”¨æƒ…å†µï¼Œæ”¯æŒé¢„è­¦å’Œé™åˆ¶
- **æŠ¥è¡¨ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆéƒ¨é—¨çº§ã€é¡¹ç›®çº§æˆæœ¬æŠ¥è¡¨

#### 3.3 æƒé™ç®¡ç†ç³»ç»Ÿ
```yaml
è§’è‰²æƒé™çŸ©é˜µ:
  ä¼ä¸šç®¡ç†å‘˜:
    - è´¦å·æ± ï¼šåˆ›å»ºã€ç¼–è¾‘ã€åˆ é™¤ã€æŸ¥çœ‹
    - æ‹¼è½¦ç»„ï¼šå…¨éƒ¨æƒé™
    - ç”¨æˆ·ï¼šå…¨éƒ¨æƒé™  
    - ç»Ÿè®¡ï¼šå…¨ä¼ä¸šæ•°æ®
    - è®¾ç½®ï¼šç³»ç»Ÿé…ç½®
    
  éƒ¨é—¨ç®¡ç†å‘˜:
    - è´¦å·æ± ï¼šæŸ¥çœ‹
    - æ‹¼è½¦ç»„ï¼šéƒ¨é—¨å†…ç®¡ç†
    - ç”¨æˆ·ï¼šéƒ¨é—¨å†…ç®¡ç†
    - ç»Ÿè®¡ï¼šéƒ¨é—¨æ•°æ®
    - è®¾ç½®ï¼šéƒ¨é—¨é…ç½®
    
  æ‹¼è½¦ç»„é•¿:
    - æ‹¼è½¦ç»„ï¼šæœ¬ç»„ç®¡ç†
    - ç”¨æˆ·ï¼šæœ¬ç»„æˆå‘˜ç®¡ç†
    - ç»Ÿè®¡ï¼šæœ¬ç»„æ•°æ®
    
  æ™®é€šç”¨æˆ·:
    - ä½¿ç”¨ï¼šAIæœåŠ¡è°ƒç”¨
    - æŸ¥çœ‹ï¼šä¸ªäººç»Ÿè®¡
```

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„è®¾è®¡

### 1. ç³»ç»Ÿæ¶æ„å›¾

#### 1.1 ä¼ä¸šçº§å¤šæ¨¡å‹æ•´ä½“æ¶æ„å›¾
```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        A1[ç®¡ç†åå°] 
        A2[Claude Code CLI]
        A3[Gemini CLI]
        A4[AmpCode CLI]
    end
    
    subgraph "APIç½‘å…³å±‚"
        B1[è´Ÿè½½å‡è¡¡å™¨] --> B2[API Gateway]
        B2 --> B3[è®¤è¯ä¸­é—´ä»¶]
        B2 --> B4[é™æµä¸­é—´ä»¶]
        B2 --> B5[æ¨¡å‹è·¯ç”±ä¸­é—´ä»¶]
    end
    
    subgraph "åº”ç”¨æœåŠ¡å±‚"
        C1[è´¦å·æ± ç®¡ç†æœåŠ¡]
        C2[å¤šæ¨¡å‹æ™ºèƒ½åˆ†é…æœåŠ¡]
        C3[æ‹¼è½¦ç»„ç®¡ç†æœåŠ¡]
        C4[ç»Ÿè®¡åˆ†ææœåŠ¡]
        C5[ç›‘æ§æœåŠ¡]
        C6[æ¨¡å‹é…ç½®æœåŠ¡]
        C7[æ•…éšœè½¬ç§»æœåŠ¡]
    end
    
    subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
        D1[ä¼ä¸šçº§è´Ÿè½½å‡è¡¡å™¨]
        D2[å¤šæ¨¡å‹å¥åº·æ£€æŸ¥å™¨]
        D3[ä½¿ç”¨é™é¢æ§åˆ¶å™¨]
        D4[æˆæœ¬è®¡ç®—å™¨]
        D5[æ•…éšœè½¬ç§»å¼•æ“]
        D6[æ¨¡å‹æ€§èƒ½ç›‘æ§å™¨]
    end
    
    subgraph "æ•°æ®å±‚"
        E1[(ä¸»æ•°æ®åº“<br/>MySQL)]
        E2[(ç¼“å­˜<br/>Redis)]
        E3[(æ—¶åºæ•°æ®åº“<br/>InfluxDB)]
        E4[(å¯¹è±¡å­˜å‚¨<br/>MinIO)]
        E5[(æ¨¡å‹é…ç½®å­˜å‚¨)]
        E6[(æ•…éšœè½¬ç§»æ—¥å¿—)]
    end
    
    subgraph "AIæœåŠ¡å±‚"
        subgraph "Claude Code å¤šæ¨¡å‹æ± "
            F1[Claude 4 Sonnet]
            F2[Claude 4 Opus]
            F3[Kimi K2]
            F4[GLM4.5]
            F5[Qwen3]
        end
        
        subgraph "ç‹¬ç«‹æœåŠ¡"
            F6[Gemini API]
            F7[AmpCode API]
            F8[å…¶ä»–AIæœåŠ¡]
        end
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    A4 --> B1
    
    B3 --> C1
    B3 --> C2
    B3 --> C3
    B4 --> C4
    B4 --> C5
    B5 --> C6
    B5 --> C7
    
    C1 --> D1
    C2 --> D2
    C3 --> D3
    C4 --> D4
    C6 --> D5
    C7 --> D6
    
    D1 --> E1
    D2 --> E2
    D3 --> E3
    D4 --> E4
    D5 --> E5
    D6 --> E6
    
    C2 --> F1
    C2 --> F2
    C2 --> F3
    C2 --> F4
    C2 --> F5
    C2 --> F6
    C2 --> F7
    C2 --> F8
    
    D5 --> F1
    D5 --> F2
    D5 --> F3
    D5 --> F4
    D5 --> F5
    
    style A2 fill:#e3f2fd
    style C2 fill:#fff3e0
    style D5 fill:#ffebee
    style F1 fill:#e8f5e8
    style F3 fill:#f3e5f5
```

#### 1.2 ä¼ä¸šçº§å¤šæ¨¡å‹è´¦å·æ± æ¶æ„å›¾
```mermaid
graph TB
    subgraph "ä¼ä¸šA"
        subgraph "Claude Code å¤šæ¨¡å‹è´¦å·æ± "
            subgraph "ä¸»æ¨¡å‹æ± "
                P1[Claude 4 Sonnet]
                P2[Claude 4 Opus]
            end
            
            subgraph "å¤‡ç”¨æ¨¡å‹æ± "
                B1[Kimi K2]
                B2[GLM4.5]
                B3[Qwen3]
            end
        end
        
        subgraph "ç‹¬ç«‹æœåŠ¡è´¦å·æ± "
            subgraph "Geminiä¸“å±æ± "
                G1[Gemini Pro]
                G2[Gemini Ultra]
            end
            
            subgraph "AmpCodeä¸“å±æ± "
                A1[AmpCode Basic]
                A2[AmpCode Pro]
            end
        end
        
        subgraph "æ‹¼è½¦ç»„"
            T1[å‰ç«¯ç»„<br/>20äºº<br/>Claude Code]
            T2[åç«¯ç»„<br/>30äºº<br/>Claude Code]
            T3[æµ‹è¯•ç»„<br/>15äºº<br/>Gemini]
            T4[æ•°æ®ç»„<br/>10äºº<br/>AmpCode]
        end
    end
    
    subgraph "å¤šæ¨¡å‹æ™ºèƒ½åˆ†é…å¼•æ“"
        MR[æ¨¡å‹è·¯ç”±å™¨]
        FE[æ•…éšœè½¬ç§»å¼•æ“]
        HC[å¥åº·æ£€æŸ¥å™¨]
        LC[é™é¢æ§åˆ¶å™¨]
        MC[æ¨¡å‹é…ç½®ç®¡ç†]
    end
    
    subgraph "ç›‘æ§å‘Šè­¦"
        PM[æ€§èƒ½ç›‘æ§]
        AL[æ•…éšœå‘Šè­¦]
        CS[æˆæœ¬ç»Ÿè®¡]
    end
    
    T1 --> MR
    T2 --> MR
    T3 -.-> G1
    T3 -.-> G2
    T4 -.-> A1
    T4 -.-> A2
    
    MR --> P1
    MR --> P2
    FE -.-> B1
    FE -.-> B2
    FE -.-> B3
    
    HC --> P1
    HC --> P2
    HC --> B1
    HC --> B2
    HC --> B3
    HC --> G1
    HC --> G2
    HC --> A1
    HC --> A2
    
    LC --> T1
    LC --> T2
    LC --> T3
    LC --> T4
    
    MC --> MR
    MC --> FE
    
    PM --> MR
    AL --> FE
    CS --> LC
    
    style T1 fill:#e3f2fd
    style T2 fill:#e3f2fd
    style P1 fill:#e8f5e8
    style P2 fill:#e8f5e8
    style B1 fill:#ffebee
    style B2 fill:#ffebee
    style B3 fill:#ffebee
    style MR fill:#fff3e0
    style FE fill:#f3e5f5
```

### 2. æ ¸å¿ƒæµç¨‹å›¾

#### 2.1 å¤šæ¨¡å‹æ™ºèƒ½åˆ†é…æµç¨‹å›¾
```mermaid
flowchart TD
    A[ç”¨æˆ·å‘èµ·AIè¯·æ±‚] --> B{ç”¨æˆ·è®¤è¯}
    B -->|å¤±è´¥| C[è¿”å›401é”™è¯¯]
    B -->|æˆåŠŸ| D[è·å–ç”¨æˆ·æ‹¼è½¦ç»„]
    
    D --> E[è¯†åˆ«æœåŠ¡ç±»å‹]
    E --> F{Claude Code CLI?}
    F -->|å¦| G[ä½¿ç”¨åŸæœ‰å•æ¨¡å‹é€»è¾‘]
    F -->|æ˜¯| H[è·å–å¤šæ¨¡å‹é…ç½®]
    
    H --> I[æ£€æŸ¥å½“å‰æ´»è·ƒæ¨¡å‹]
    I --> J{ä¸»æ¨¡å‹å¥åº·?}
    J -->|æ˜¯| K[ä½¿ç”¨ä¸»æ¨¡å‹å¤„ç†]
    J -->|å¦| L[è§¦å‘æ•…éšœè½¬ç§»]
    
    L --> M[è·å–å¤‡ç”¨æ¨¡å‹åˆ—è¡¨]
    M --> N[æŒ‰ä¼˜å…ˆçº§æ’åº]
    N --> O[é€‰æ‹©é¦–é€‰å¤‡ç”¨æ¨¡å‹]
    
    O --> P{å¤‡ç”¨æ¨¡å‹å¥åº·?}
    P -->|å¦| Q[å°è¯•ä¸‹ä¸€ä¸ªå¤‡ç”¨æ¨¡å‹]
    Q --> P
    P -->|æ˜¯| R[åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹]
    
    R --> S[è®°å½•æ•…éšœè½¬ç§»äº‹ä»¶]
    S --> T[æ›´æ–°æ´»è·ƒæ¨¡å‹çŠ¶æ€]
    T --> K
    
    K --> U[æ£€æŸ¥ä½¿ç”¨é™é¢]
    U --> V{æ˜¯å¦è¶…é™}
    V -->|æ˜¯| W[åŠ å…¥ç­‰å¾…é˜Ÿåˆ—]
    V -->|å¦| X[å‘é€è¯·æ±‚åˆ°AIæœåŠ¡]
    
    X --> Y{è¯·æ±‚æˆåŠŸ}
    Y -->|å¤±è´¥| Z[è®°å½•é”™è¯¯ç»Ÿè®¡]
    Z --> AA{å¯ç”¨è‡ªåŠ¨æ•…éšœè½¬ç§»?}
    AA -->|æ˜¯| L
    AA -->|å¦| BB[è¿”å›é”™è¯¯]
    
    Y -->|æˆåŠŸ| CC[è®°å½•ä½¿ç”¨é‡å’Œæ€§èƒ½æŒ‡æ ‡]
    CC --> DD[æ›´æ–°æ¨¡å‹å¥åº·åˆ†æ•°]
    DD --> EE[è¿”å›ç»“æœç»™ç”¨æˆ·]
    
    G --> FF[åŸæœ‰å•æ¨¡å‹å¤„ç†æµç¨‹]
    W --> GG[ç­‰å¾…èµ„æºé‡Šæ”¾]
    GG --> U
    
    style A fill:#e1f5fe
    style F fill:#fff3e0
    style L fill:#ffebee
    style R fill:#f3e5f5
    style EE fill:#e8f5e8
```

#### 2.2 å¤šæ¨¡å‹æˆæœ¬åˆ†æ‘Šæµç¨‹å›¾
```mermaid
flowchart TD
    A[AIè¯·æ±‚å®Œæˆ] --> B[è®°å½•ä½¿ç”¨æ•°æ®]
    B --> C[è¯†åˆ«ä½¿ç”¨çš„å…·ä½“æ¨¡å‹]
    C --> D[è®¡ç®—Tokenä½¿ç”¨é‡]
    D --> E[æŒ‰æ¨¡å‹è®¡ç®—å®é™…æˆæœ¬]
    
    E --> F[è®°å½•æ¨¡å‹åˆ‡æ¢å†å²]
    F --> G[ç¡®å®šåˆ†æ‘Šç­–ç•¥]
    G --> H{åˆ†æ‘Šç±»å‹}
    
    H -->|æŒ‰ä½¿ç”¨é‡| I[æŒ‰æ¨¡å‹ç²¾ç¡®åˆ†æ‘Š]
    H -->|å›ºå®šåˆ†æ‘Š| J[æŒ‰å›ºå®šæ¯”ä¾‹åˆ†æ‘Š]
    H -->|åŠ æƒåˆ†æ‘Š| K[æŒ‰æƒé‡åˆ†æ‘Š]
    
    I --> L[æ›´æ–°ç»„å¤šæ¨¡å‹ä½¿ç”¨ç»Ÿè®¡]
    J --> L
    K --> L
    
    L --> M[æ›´æ–°ç”¨æˆ·æ¨¡å‹ä½¿ç”¨ç»Ÿè®¡]
    M --> N[æ›´æ–°éƒ¨é—¨æ¨¡å‹ç»Ÿè®¡]
    N --> O[æ›´æ–°ä¼ä¸šçº§æ¨¡å‹ç»Ÿè®¡]
    
    O --> P[è®¡ç®—æ¨¡å‹æˆæœ¬æ•ˆç›Š]
    P --> Q{é¢„ç®—æ£€æŸ¥}
    Q -->|æ¥è¿‘é¢„ç®—| R[å‘é€é¢„è­¦é€šçŸ¥]
    Q -->|è¶…å‡ºé¢„ç®—| S[è§¦å‘æ¨¡å‹é™çº§ç­–ç•¥]
    Q -->|æ­£å¸¸| T[æ›´æ–°å®Œæˆ]
    
    R --> U[è¯„ä¼°æ˜¯å¦åˆ‡æ¢ä½æˆæœ¬æ¨¡å‹]
    S --> V[è‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹]
    V --> W[è®°å½•æˆæœ¬æ§åˆ¶äº‹ä»¶]
    U --> T
    W --> T
    
    style C fill:#e1f5fe
    style P fill:#fff3e0
    style S fill:#ffebee
    style T fill:#e8f5e8
```

### 3. æ—¶åºå›¾

#### 3.1 å¤šæ¨¡å‹ç”¨æˆ·è¯·æ±‚å¤„ç†æ—¶åºå›¾
```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·(Claude Code CLI)
    participant API as API Gateway
    participant Auth as è®¤è¯æœåŠ¡
    participant MR as å¤šæ¨¡å‹è·¯ç”±å™¨
    participant MC as æ¨¡å‹é…ç½®æœåŠ¡
    participant FE as æ•…éšœè½¬ç§»å¼•æ“
    participant HC as å¥åº·æ£€æŸ¥å™¨
    participant AI1 as Claude 4 Sonnet
    participant AI2 as Kimi K2(å¤‡ç”¨)
    participant Monitor as ç›‘æ§æœåŠ¡
    participant DB as æ•°æ®åº“
    
    U->>API: å‘èµ·AIè¯·æ±‚
    API->>Auth: éªŒè¯ç”¨æˆ·token
    Auth-->>API: è¿”å›ç”¨æˆ·ä¿¡æ¯
    
    API->>MR: è¯·æ±‚æ¨¡å‹è·¯ç”±
    MR->>MC: è·å–ç»„æ¨¡å‹é…ç½®
    MC-->>MR: è¿”å›ä¸»æ¨¡å‹å’Œå¤‡ç”¨æ¨¡å‹åˆ—è¡¨
    
    MR->>HC: æ£€æŸ¥ä¸»æ¨¡å‹å¥åº·çŠ¶æ€
    HC->>AI1: å‘é€å¥åº·æ£€æŸ¥
    AI1-->>HC: è¿”å›å¥åº·çŠ¶æ€
    HC-->>MR: ä¸»æ¨¡å‹å¥åº·
    
    MR->>AI1: è½¬å‘è¯·æ±‚åˆ°ä¸»æ¨¡å‹
    
    alt ä¸»æ¨¡å‹æ­£å¸¸å“åº”
        AI1-->>MR: è¿”å›AIå“åº”
        MR-->>API: è¿”å›å¤„ç†ç»“æœ
        API-->>U: è¿”å›æœ€ç»ˆå“åº”
        
        par å¼‚æ­¥å¤„ç†
            MR->>Monitor: è®°å½•ä½¿ç”¨é‡å’Œæ¨¡å‹ä¿¡æ¯
            Monitor->>DB: æ›´æ–°å¤šæ¨¡å‹ç»Ÿè®¡æ•°æ®
            
            MR->>HC: æ›´æ–°æ¨¡å‹å¥åº·åˆ†æ•°
            HC->>DB: æ›´æ–°æ¨¡å‹çŠ¶æ€
        end
    
    else ä¸»æ¨¡å‹æ•…éšœ
        AI1-->>MR: è¿”å›é”™è¯¯/è¶…æ—¶
        MR->>FE: è§¦å‘æ•…éšœè½¬ç§»
        FE->>HC: æ£€æŸ¥å¤‡ç”¨æ¨¡å‹å¥åº·
        HC->>AI2: å¥åº·æ£€æŸ¥å¤‡ç”¨æ¨¡å‹
        AI2-->>HC: è¿”å›å¥åº·çŠ¶æ€
        HC-->>FE: å¤‡ç”¨æ¨¡å‹å¯ç”¨
        
        FE->>AI2: è½¬å‘è¯·æ±‚åˆ°å¤‡ç”¨æ¨¡å‹
        AI2-->>FE: è¿”å›AIå“åº”
        FE-->>MR: è¿”å›æ•…éšœè½¬ç§»ç»“æœ
        MR-->>API: è¿”å›å¤„ç†ç»“æœ
        API-->>U: è¿”å›æœ€ç»ˆå“åº”
        
        par å¼‚æ­¥å¤„ç†
            FE->>Monitor: è®°å½•æ•…éšœè½¬ç§»äº‹ä»¶
            Monitor->>DB: æ›´æ–°æ•…éšœè½¬ç§»æ—¥å¿—
            
            FE->>MC: æ›´æ–°æ´»è·ƒæ¨¡å‹çŠ¶æ€
            MC->>DB: æŒä¹…åŒ–æ¨¡å‹é…ç½®å˜æ›´
        end
    end
```

#### 3.2 å¤šæ¨¡å‹æ•…éšœè½¬ç§»å’Œæ¢å¤æ—¶åºå›¾
```mermaid
sequenceDiagram
    participant Admin as ç®¡ç†å‘˜
    participant MC as æ¨¡å‹é…ç½®æœåŠ¡
    participant MR as å¤šæ¨¡å‹è·¯ç”±å™¨
    participant FE as æ•…éšœè½¬ç§»å¼•æ“
    participant HC as å¥åº·æ£€æŸ¥å™¨
    participant AI1 as Claude 4 Sonnet(ä¸»)
    participant AI2 as Claude 4 Opus(å¤‡ç”¨1)
    participant AI3 as Kimi K2(å¤‡ç”¨2)
    participant Alert as å‘Šè­¦æœåŠ¡
    participant DB as æ•°æ®åº“
    
    Note over MR,HC: æ­£å¸¸æœåŠ¡é˜¶æ®µ
    MR->>HC: å®šæœŸå¥åº·æ£€æŸ¥ä¸»æ¨¡å‹
    HC->>AI1: å‘é€å¥åº·æ£€æŸ¥è¯·æ±‚
    AI1-->>HC: è¿æ¥è¶…æ—¶/æœåŠ¡å¼‚å¸¸
    HC->>HC: è¿ç»­3æ¬¡æ£€æŸ¥å¤±è´¥
    
    Note over FE,Alert: æ•…éšœæ£€æµ‹å’Œå‘Šè­¦
    HC->>FE: è§¦å‘æ•…éšœè½¬ç§»
    HC->>Alert: å‘é€ä¸»æ¨¡å‹æ•…éšœå‘Šè­¦
    Alert->>Admin: é€šçŸ¥ç®¡ç†å‘˜ä¸»æ¨¡å‹å¼‚å¸¸
    
    Note over FE,AI3: æ•…éšœè½¬ç§»è¿‡ç¨‹
    FE->>HC: æ£€æŸ¥å¤‡ç”¨æ¨¡å‹1å¥åº·çŠ¶æ€
    HC->>AI2: å¥åº·æ£€æŸ¥Claude 4 Opus
    AI2-->>HC: è¿”å›æ­£å¸¸çŠ¶æ€
    HC-->>FE: å¤‡ç”¨æ¨¡å‹1å¯ç”¨
    
    FE->>MR: åˆ‡æ¢æ´»è·ƒæ¨¡å‹åˆ°å¤‡ç”¨1
    FE->>DB: è®°å½•æ•…éšœè½¬ç§»äº‹ä»¶
    MR->>MC: æ›´æ–°ç»„æ´»è·ƒæ¨¡å‹é…ç½®
    
    Note over MR,AI2: ä½¿ç”¨å¤‡ç”¨æ¨¡å‹æœåŠ¡
    MR->>AI2: è·¯ç”±ç”¨æˆ·è¯·æ±‚åˆ°å¤‡ç”¨æ¨¡å‹
    AI2-->>MR: è¿”å›æ­£å¸¸å“åº”
    
    Note over HC,AI1: åå°æ•…éšœæ¢å¤æ£€æŸ¥
    par åå°æ¢å¤ç›‘æ§
        HC->>AI1: æ¯5åˆ†é’Ÿé‡è¯•å¥åº·æ£€æŸ¥
        AI1-->>HC: æœåŠ¡æ¢å¤æ­£å¸¸
        HC->>HC: è¿ç»­3æ¬¡æ£€æŸ¥æˆåŠŸ
        
        HC->>FE: ä¸»æ¨¡å‹æ¢å¤å¯ç”¨
        FE->>Alert: å‘é€æ¨¡å‹æ¢å¤é€šçŸ¥
        Alert->>Admin: é€šçŸ¥ç®¡ç†å‘˜ä¸»æ¨¡å‹å·²æ¢å¤
        
        Note over FE,MR: å¯é€‰ï¼šè‡ªåŠ¨åˆ‡å›ä¸»æ¨¡å‹
        alt å¯ç”¨è‡ªåŠ¨æ•…éšœæ¢å¤
            FE->>MR: åˆ‡æ¢å›ä¸»æ¨¡å‹
            FE->>DB: è®°å½•æ•…éšœæ¢å¤äº‹ä»¶
            MR->>MC: æ›´æ–°æ´»è·ƒæ¨¡å‹ä¸ºä¸»æ¨¡å‹
        else æ‰‹åŠ¨åˆ‡å›æ¨¡å¼
            Admin->>MC: æ‰‹åŠ¨ç¡®è®¤åˆ‡å›ä¸»æ¨¡å‹
            MC->>MR: æ‰§è¡Œæ¨¡å‹åˆ‡æ¢
            MR->>DB: è®°å½•æ‰‹åŠ¨åˆ‡æ¢äº‹ä»¶
        end
    end
```

#### 3.3 æ‰‹åŠ¨æ¨¡å‹åˆ‡æ¢ç®¡ç†æµç¨‹å›¾
```mermaid
flowchart TD
    A[ç®¡ç†å‘˜ç™»å½•åå°] --> B[é€‰æ‹©æ‹¼è½¦ç»„]
    B --> C[æŸ¥çœ‹å½“å‰æ¨¡å‹çŠ¶æ€]
    C --> D{éœ€è¦åˆ‡æ¢æ¨¡å‹?}
    
    D -->|å¦| E[ç›‘æ§æ¨¡å‹æ€§èƒ½]
    D -->|æ˜¯| F[æŸ¥çœ‹å¯ç”¨æ¨¡å‹åˆ—è¡¨]
    
    F --> G[é€‰æ‹©ç›®æ ‡æ¨¡å‹]
    G --> H[æ£€æŸ¥ç›®æ ‡æ¨¡å‹å¥åº·çŠ¶æ€]
    H --> I{ç›®æ ‡æ¨¡å‹å¯ç”¨?}
    
    I -->|å¦| J[æ˜¾ç¤ºæ¨¡å‹ä¸å¯ç”¨æç¤º]
    J --> F
    I -->|æ˜¯| K[ç¡®è®¤åˆ‡æ¢åŸå› ]
    
    K --> L{åˆ‡æ¢åŸå› }
    L -->|ç»´æŠ¤| M[è®¾ç½®ç»´æŠ¤æ¨¡å¼]
    L -->|æ€§èƒ½ä¼˜åŒ–| N[è®°å½•æ€§èƒ½ä¼˜åŒ–åŸå› ]
    L -->|æˆæœ¬æ§åˆ¶| O[è®°å½•æˆæœ¬æ§åˆ¶åŸå› ]
    
    M --> P[æ‰§è¡Œæ¨¡å‹åˆ‡æ¢]
    N --> P
    O --> P
    
    P --> Q[éªŒè¯åˆ‡æ¢æˆåŠŸ]
    Q --> R{åˆ‡æ¢æˆåŠŸ?}
    
    R -->|å¦| S[å›æ»šåˆ°åŸæ¨¡å‹]
    S --> T[è®°å½•åˆ‡æ¢å¤±è´¥äº‹ä»¶]
    T --> U[é€šçŸ¥ç®¡ç†å‘˜åˆ‡æ¢å¤±è´¥]
    
    R -->|æ˜¯| V[æ›´æ–°æ´»è·ƒæ¨¡å‹çŠ¶æ€]
    V --> W[è®°å½•åˆ‡æ¢æˆåŠŸäº‹ä»¶]
    W --> X[å‘é€åˆ‡æ¢é€šçŸ¥]
    X --> Y[æ›´æ–°ç›‘æ§é¢æ¿]
    
    E --> Z[å®šæœŸæ£€æŸ¥æ¨¡å‹çŠ¶æ€]
    U --> E
    Y --> E
    Z --> D
    
    style A fill:#e1f5fe
    style P fill:#fff3e0
    style V fill:#e8f5e8
    style S fill:#ffebee
```

### 4. æ•°æ®åº“ç»“æ„è®¾è®¡

#### 4.1 åŸºäºç°æœ‰Prisma Schemaçš„æ‰©å±•è®¾è®¡

**ç°æœ‰æ ¸å¿ƒæ¨¡å‹**ï¼š
- `Group` - æ‹¼è½¦ç»„
- `AiServiceAccount` - AIæœåŠ¡è´¦å·  
- `GroupAiService` - æ‹¼è½¦ç»„ä¸AIæœåŠ¡ç»‘å®š
- `UsageStat` - ä½¿ç”¨ç»Ÿè®¡
- `QuotaConfig` / `QuotaUsage` - é…é¢ç®¡ç†

#### 4.2 ä¼ä¸šçº§æ‰©å±•æ¨¡å‹

```prisma
// ä¼ä¸šç»„ç»‡è¡¨
model Enterprise {
  id          String   @id @default(cuid())
  name        String
  planType    String   @default("basic") // "basic", "enterprise", "custom"
  settings    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // å…³è”å…³ç³»
  accountPools AccountPool[]
  departments  Department[]
  
  @@map("enterprises")
}

// éƒ¨é—¨è¡¨ (æ”¯æŒå±‚çº§ç»“æ„)
model Department {
  id           String   @id @default(cuid())
  enterpriseId String
  parentId     String?  // æ”¯æŒå±‚çº§ç»“æ„
  name         String
  description  String?
  budgetLimit  Decimal? @db.Decimal(10, 2)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // å…³è”å…³ç³»
  enterprise   Enterprise   @relation(fields: [enterpriseId], references: [id], onDelete: Cascade)
  parent       Department?  @relation("DepartmentHierarchy", fields: [parentId], references: [id])
  children     Department[] @relation("DepartmentHierarchy") 
  groups       Group[]      @relation("DepartmentGroups")
  
  @@index([enterpriseId])
  @@map("departments")
}

// è´¦å·æ± è¡¨
model AccountPool {
  id                  String   @id @default(cuid())
  enterpriseId        String
  name                String
  description         String?
  poolType            String   @default("shared") // "shared", "dedicated"
  loadBalanceStrategy String   @default("round_robin") // "round_robin", "least_connections", "weighted"
  maxLoadPerAccount   Int      @default(80)
  priority            Int      @default(1)
  isActive            Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  // å…³è”å…³ç³»
  enterprise       Enterprise           @relation(fields: [enterpriseId], references: [id], onDelete: Cascade)
  accountBindings  AccountPoolBinding[]
  groupBindings    GroupPoolBinding[]
  
  @@index([enterpriseId])
  @@map("account_pools")
}

// è´¦å·æ± ä¸AIè´¦å·ç»‘å®šè¡¨
model AccountPoolBinding {
  id                String   @id @default(cuid())
  poolId            String
  accountId         String
  weight            Int      @default(1)
  maxLoadPercentage Int      @default(80)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  
  // å…³è”å…³ç³»
  pool    AccountPool      @relation(fields: [poolId], references: [id], onDelete: Cascade)
  account AiServiceAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  @@unique([poolId, accountId])
  @@index([accountId])
  @@map("account_pool_bindings")
}

// æ‹¼è½¦ç»„ä¸è´¦å·æ± ç»‘å®šè¡¨
model GroupPoolBinding {
  id                String   @id @default(cuid())
  groupId           String
  poolId            String
  bindingType       String   @default("shared") // "primary", "fallback", "shared"
  usageLimitHourly  Int      @default(0) // 0è¡¨ç¤ºæ— é™åˆ¶
  usageLimitDaily   Int      @default(0)
  usageLimitMonthly Int      @default(0)
  priority          Int      @default(1)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // å…³è”å…³ç³»
  group Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  pool  AccountPool @relation(fields: [poolId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, poolId])
  @@index([poolId])
  @@map("group_pool_bindings")
}

// æ‰©å±•ç°æœ‰Groupæ¨¡å‹ä»¥æ”¯æŒéƒ¨é—¨å…³è”
model Group {
  // ... ç°æœ‰å­—æ®µä¿æŒä¸å˜
  departmentId String?
  
  // æ–°å¢å…³è”å…³ç³»
  department     Department?        @relation("DepartmentGroups", fields: [departmentId], references: [id])
  poolBindings   GroupPoolBinding[]
  
  @@index([departmentId])
}

// æ‰©å±•ç°æœ‰AiServiceAccountæ¨¡å‹ä»¥æ”¯æŒè´¦å·æ± 
model AiServiceAccount {
  // ... ç°æœ‰å­—æ®µä¿æŒä¸å˜
  
  // æ–°å¢å…³è”å…³ç³»
  poolBindings AccountPoolBinding[]
}

// å¢å¼ºä½¿ç”¨è®°å½•è¡¨ä»¥æ”¯æŒè´¦å·æ± ç»Ÿè®¡
model EnhancedUsageStat {
  id            String    @id @default(cuid())
  userId        String
  groupId       String
  accountId     String?   // å®é™…ä½¿ç”¨çš„è´¦å·ID
  poolId        String?   // è´¦å·æ‰€å±æ± ID
  aiServiceId   String    // æœåŠ¡ç±»å‹
  requestType   String
  requestTokens Int       @default(0)
  responseTokens Int      @default(0)
  totalTokens   BigInt
  cost          Decimal   @db.Decimal(10, 6)
  requestTime   DateTime
  responseTime  Int?
  status        String
  errorCode     String?
  metadata      Json?
  
  // å…³è”å…³ç³»
  user    User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  group   Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  account AiServiceAccount? @relation(fields: [accountId], references: [id], onDelete: SetNull)
  pool    AccountPool?     @relation(fields: [poolId], references: [id], onDelete: SetNull)
  
  @@index([userId, requestTime])
  @@index([groupId, requestTime])
  @@index([accountId, requestTime])
  @@index([poolId, requestTime])
  @@map("enhanced_usage_stats")
}

// é¢„ç®—åˆ†é…è¡¨
model BudgetAllocation {
  id           String   @id @default(cuid())
  entityType   String   // "enterprise", "department", "group"
  entityId     String   // å¯¹åº”çš„å®ä½“ID
  budgetPeriod String   @default("monthly") // "monthly", "quarterly", "yearly"
  budgetAmount Decimal  @db.Decimal(10, 2)
  usedAmount   Decimal  @default(0) @db.Decimal(10, 2)
  periodStart  DateTime
  periodEnd    DateTime
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@unique([entityType, entityId, budgetPeriod, periodStart])
  @@index([entityType, entityId])
  @@map("budget_allocations")
}
```

#### 1.2 ç¼“å­˜ç­–ç•¥
```yaml
ç¼“å­˜å±‚è®¾è®¡:
  L1 - åº”ç”¨ç¼“å­˜ (å†…å­˜):
    - è´¦å·æ± é…ç½®: 5åˆ†é’Ÿ
    - è´Ÿè½½çŠ¶æ€: 30ç§’
    - ç”¨æˆ·æƒé™: 10åˆ†é’Ÿ
    
  L2 - Redisç¼“å­˜:  
    - è´¦å·å¯ç”¨æ€§: 1åˆ†é’Ÿ
    - ä½¿ç”¨é™é¢è®¡æ•°å™¨: å®æ—¶
    - ç»Ÿè®¡æ•°æ®: 5åˆ†é’Ÿ
    - åˆ†é…ç®—æ³•ç»“æœ: 30ç§’
    
  L3 - æ•°æ®åº“:
    - æŒä¹…åŒ–å­˜å‚¨
    - å†å²æ•°æ®
    - é…ç½®ä¿¡æ¯
```

### 5. APIæ¥å£è®¾è®¡

#### 5.1 åŸºäºNext.js App Routerçš„APIè®¾è®¡

**APIè·¯ç”±ç»“æ„**ï¼š
```
/api/
â”œâ”€â”€ enterprises/
â”‚   â”œâ”€â”€ [enterpriseId]/
â”‚   â”‚   â”œâ”€â”€ route.ts                    # ä¼ä¸šCRUD
â”‚   â”‚   â”œâ”€â”€ departments/
â”‚   â”‚   â”‚   â””â”€â”€ route.ts                # éƒ¨é—¨ç®¡ç†
â”‚   â”‚   â””â”€â”€ account-pools/
â”‚   â”‚       â”œâ”€â”€ route.ts                # è´¦å·æ± åˆ—è¡¨
â”‚   â”‚       â””â”€â”€ [poolId]/
â”‚   â”‚           â””â”€â”€ route.ts            # è´¦å·æ± è¯¦æƒ…
â”œâ”€â”€ groups/
â”‚   â””â”€â”€ [groupId]/
â”‚       â”œâ”€â”€ account-pools/
â”‚       â”‚   â”œâ”€â”€ route.ts                # ç»„ç»‘å®šçš„è´¦å·æ± 
â”‚       â”‚   â””â”€â”€ bindings/
â”‚       â”‚       â””â”€â”€ route.ts            # æ± ç»‘å®šç®¡ç†
â”‚       â””â”€â”€ ai-allocation/
â”‚           â””â”€â”€ route.ts                # æ™ºèƒ½åˆ†é…æ¥å£
â””â”€â”€ admin/
    â”œâ”€â”€ account-pools/
    â”‚   â””â”€â”€ route.ts                    # å…¨å±€è´¦å·æ± ç®¡ç†
    â””â”€â”€ load-balancer/
        â””â”€â”€ route.ts                    # è´Ÿè½½å‡è¡¡çŠ¶æ€
```

#### 5.2 æ ¸å¿ƒAPIæ¥å£å®ç°

**ä¼ä¸šçº§è´¦å·æ± ç®¡ç†API**ï¼š
```typescript
// /api/enterprises/[enterpriseId]/account-pools/route.ts
import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { withAuth, createApiResponse } from '@/lib/middleware';

// è·å–ä¼ä¸šè´¦å·æ± åˆ—è¡¨
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ enterpriseId: string }> }
) {
  const { enterpriseId } = await params;
  
  try {
    const pools = await prisma.accountPool.findMany({
      where: { enterpriseId },
      include: {
        accountBindings: {
          include: {
            account: {
              select: {
                id: true,
                name: true,
                serviceType: true,
                status: true
              }
            }
          }
        },
        groupBindings: {
          include: {
            group: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        _count: {
          select: {
            accountBindings: true,
            groupBindings: true
          }
        }
      },
      orderBy: { priority: 'asc' }
    });

    return createApiResponse(pools, true, 200);
  } catch (error) {
    console.error('Get account pools error:', error);
    return createApiResponse(false, null, 'è·å–è´¦å·æ± åˆ—è¡¨å¤±è´¥', 500);
  }
}

// åˆ›å»ºè´¦å·æ± 
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ enterpriseId: string }> }
) {
  const { enterpriseId } = await params;
  
  try {
    const body = await request.json();
    const {
      name,
      description,
      poolType,
      loadBalanceStrategy,
      maxLoadPerAccount,
      priority,
      accountIds
    } = body;

    // åˆ›å»ºè´¦å·æ± 
    const pool = await prisma.accountPool.create({
      data: {
        enterpriseId,
        name,
        description,
        poolType,
        loadBalanceStrategy,
        maxLoadPerAccount,
        priority,
        accountBindings: {
          create: accountIds.map((accountId: string) => ({
            accountId,
            weight: 1,
            maxLoadPercentage: maxLoadPerAccount
          }))
        }
      },
      include: {
        accountBindings: {
          include: {
            account: true
          }
        }
      }
    });

    return createApiResponse(pool, true, 201);
  } catch (error) {
    console.error('Create account pool error:', error);
    return createApiResponse(false, null, 'åˆ›å»ºè´¦å·æ± å¤±è´¥', 500);
  }
}
```

**æ‹¼è½¦ç»„è´¦å·æ± ç»‘å®šAPI**ï¼š
```typescript
// /api/groups/[groupId]/account-pools/bindings/route.ts
import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { cacheManager } from '@/lib/cache';
import { withAuth, createApiResponse } from '@/lib/middleware';

// è·å–æ‹¼è½¦ç»„ç»‘å®šçš„è´¦å·æ± 
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  const { groupId } = await params;
  
  try {
    const bindings = await cacheManager.getOrSet(
      `group:pool_bindings:${groupId}`,
      async () => {
        return await prisma.groupPoolBinding.findMany({
          where: { groupId, isActive: true },
          include: {
            pool: {
              include: {
                accountBindings: {
                  where: { isActive: true },
                  include: {
                    account: {
                      select: {
                        id: true,
                        name: true,
                        serviceType: true,
                        status: true,
                        lastUsedAt: true
                      }
                    }
                  }
                }
              }
            }
          },
          orderBy: { priority: 'asc' }
        });
      },
      { ttl: 300 } // 5åˆ†é’Ÿç¼“å­˜
    );

    return createApiResponse(bindings, true, 200);
  } catch (error) {
    console.error('Get group pool bindings error:', error);
    return createApiResponse(false, null, 'è·å–è´¦å·æ± ç»‘å®šå¤±è´¥', 500);
  }
}

// åˆ›å»ºæ‹¼è½¦ç»„ä¸è´¦å·æ± ç»‘å®š
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  const { groupId } = await params;
  
  try {
    const body = await request.json();
    const {
      poolId,
      bindingType,
      usageLimitHourly,
      usageLimitDaily,
      usageLimitMonthly,
      priority
    } = body;

    const binding = await prisma.groupPoolBinding.create({
      data: {
        groupId,
        poolId,
        bindingType,
        usageLimitHourly,
        usageLimitDaily,
        usageLimitMonthly,
        priority
      },
      include: {
        pool: {
          include: {
            accountBindings: {
              include: {
                account: true
              }
            }
          }
        }
      }
    });

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await cacheManager.del(`group:pool_bindings:${groupId}`);

    return createApiResponse(binding, true, 201);
  } catch (error) {
    console.error('Create group pool binding error:', error);
    return createApiResponse(false, null, 'åˆ›å»ºè´¦å·æ± ç»‘å®šå¤±è´¥', 500);
  }
}
```

**æ™ºèƒ½åˆ†é…API**ï¼š
```typescript
// /api/groups/[groupId]/ai-allocation/route.ts
import { NextRequest } from 'next/server';
import { EnterpriseAccountAllocator } from '@/lib/enterprise-allocator';
import { withAuth, createApiResponse } from '@/lib/middleware';

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ groupId: string }> }
) {
  const { groupId } = await params;
  
  try {
    const body = await request.json();
    const { serviceType, estimatedTokens, priority } = body;

    const allocator = new EnterpriseAccountAllocator(prisma, cacheManager);
    
    const account = await allocator.allocateAccount({
      groupId,
      serviceType,
      estimatedTokens,
      priority
    });

    if (!account) {
      return createApiResponse(null, false, 'æš‚æ— å¯ç”¨è´¦å·', 503);
    }

    return createApiResponse({
      accountId: account.id,
      accountName: account.name,
      serviceType: account.serviceType,
      allocatedAt: new Date().toISOString()
    }, true, 200);
    
  } catch (error) {
    console.error('Account allocation error:', error);
    return createApiResponse(false, null, 'è´¦å·åˆ†é…å¤±è´¥', 500);
  }
}
```

#### 2.2 æ™ºèƒ½åˆ†é…API
```yaml
# è¯·æ±‚AIæœåŠ¡
POST /api/ai-proxy/chat
Headers:
  X-Group-ID: string
  Authorization: Bearer <token>
Body:
  service: 'claude' | 'gemini' | 'copilot'
  messages: Message[]
  
# å†…éƒ¨åˆ†é…é€»è¾‘
Internal: /api/internal/allocate-account
Body:
  groupId: string
  serviceType: string  
  estimatedTokens: number
Response:
  accountId: string
  poolId: string
  allocation: object
```

#### 2.3 ç»Ÿè®¡æŠ¥è¡¨API
```yaml
# è·å–ä½¿ç”¨ç»Ÿè®¡
GET /api/groups/{groupId}/usage-stats
Query:
  period: 'day' | 'week' | 'month'
  startDate: string
  endDate: string
  
# è·å–æˆæœ¬åˆ†æ‘ŠæŠ¥è¡¨  
GET /api/enterprises/{enterpriseId}/cost-allocation
Query:
  period: 'month' | 'quarter' | 'year'
  department: string (optional)
  
# è·å–è´¦å·è´Ÿè½½ç»Ÿè®¡
GET /api/enterprises/{enterpriseId}/account-loads
Response:
  accounts: {
    accountId: string,
    currentLoad: number,
    avgLoad24h: number,
    totalRequests: number
  }[]
```

### 3. è´Ÿè½½å‡è¡¡å®ç°

#### 6.1 åŸºäºç°æœ‰AiServiceRouterçš„ä¼ä¸šçº§è´Ÿè½½å‡è¡¡

**æ‰©å±•ç°æœ‰çš„AiServiceRouterç±»**ï¼š
```typescript
// /lib/enterprise/enhanced-ai-service-router.ts
import { AiServiceRouter, ServiceRoute, RoutingConfig } from '@/lib/ai-services/router';
import { prisma } from '@/lib/prisma';
import { cacheManager } from '@/lib/cache';

interface EnterpriseServiceRoute extends ServiceRoute {
  poolId?: string;
  accountId: string;
  weight: number;
  maxLoadPercentage: number;
  currentLoad: number;
  healthScore: number;
}

interface PoolRoutingStrategy {
  poolId: string;
  strategy: 'round_robin' | 'least_connections' | 'weighted' | 'health_based';
  accounts: EnterpriseServiceRoute[];
}

export class EnterpriseAiServiceRouter extends AiServiceRouter {
  private poolStrategies: Map<string, PoolRoutingStrategy> = new Map();
  private accountLoads: Map<string, number> = new Map();
  private healthScores: Map<string, number> = new Map();

  constructor() {
    super();
  }

  /**
   * ä¸ºæ‹¼è½¦ç»„åˆå§‹åŒ–ä¼ä¸šçº§è·¯ç”±ï¼ŒåŸºäºè´¦å·æ± 
   */
  async initializeEnterpriseRoutes(groupId: string): Promise<void> {
    try {
      // è·å–ç»„ç»‘å®šçš„è´¦å·æ± 
      const poolBindings = await prisma.groupPoolBinding.findMany({
        where: { groupId, isActive: true },
        include: {
          pool: {
            include: {
              accountBindings: {
                where: { isActive: true },
                include: {
                  account: {
                    where: { isEnabled: true, status: 'active' }
                  }
                }
              }
            }
          }
        },
        orderBy: { priority: 'asc' }
      });

      // ä¸ºæ¯ä¸ªè´¦å·æ± æ„å»ºè·¯ç”±ç­–ç•¥
      for (const binding of poolBindings) {
        const pool = binding.pool;
        const routes: EnterpriseServiceRoute[] = [];

        for (const accountBinding of pool.accountBindings) {
          const account = accountBinding.account;
          if (!account) continue;

          routes.push({
            serviceId: account.id,
            serviceName: `${account.name} (${account.serviceType})`,
            priority: binding.priority,
            isEnabled: true,
            healthScore: await this.getAccountHealthScore(account.id),
            responseTime: await this.getAccountResponseTime(account.id),
            errorRate: await this.getAccountErrorRate(account.id),
            lastHealthCheck: new Date(),
            // ä¼ä¸šçº§æ‰©å±•å­—æ®µ
            poolId: pool.id,
            accountId: account.id,
            weight: accountBinding.weight,
            maxLoadPercentage: accountBinding.maxLoadPercentage,  
            currentLoad: await this.getAccountCurrentLoad(account.id)
          });
        }

        this.poolStrategies.set(pool.id, {
          poolId: pool.id,
          strategy: pool.loadBalanceStrategy as any,
          accounts: routes
        });
      }

      // ç¼“å­˜è·¯ç”±é…ç½®
      await cacheManager.set(`enterprise_routes:${groupId}`, 
        Object.fromEntries(this.poolStrategies), 300);

    } catch (error) {
      console.error('Initialize enterprise routes error:', error);
      throw error;
    }
  }

  /**
   * ä¼ä¸šçº§è´¦å·é€‰æ‹©ç®—æ³•
   */
  async selectEnterpriseAccount(
    groupId: string, 
    serviceType: string,
    options: {
      estimatedTokens?: number;
      priority?: 'high' | 'normal' | 'low';
      excludeAccounts?: string[];
    } = {}
  ): Promise<EnterpriseServiceRoute | null> {
    
    // è·å–é€‚ç”¨çš„è´¦å·æ± ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
    const availablePools = Array.from(this.poolStrategies.values())
      .filter(pool => this.hasServiceType(pool, serviceType))
      .sort((a, b) => this.getPoolPriority(a) - this.getPoolPriority(b));

    for (const pool of availablePools) {
      // æ£€æŸ¥ä½¿ç”¨é™é¢
      if (await this.checkPoolUsageLimit(groupId, pool.poolId)) {
        const account = await this.selectFromPool(pool, options);
        if (account) {
          return account;
        }
      }
    }

    return null;
  }

  /**
   * ä»è´¦å·æ± ä¸­é€‰æ‹©æœ€ä½³è´¦å·
   */
  private async selectFromPool(
    pool: PoolRoutingStrategy, 
    options: any
  ): Promise<EnterpriseServiceRoute | null> {
    
    // è¿‡æ»¤å¯ç”¨è´¦å·
    const availableAccounts = pool.accounts.filter(account => 
      account.isEnabled &&
      account.currentLoad < account.maxLoadPercentage &&
      account.healthScore > 50 && // å¥åº·åˆ†æ•°å¤§äº50
      !options.excludeAccounts?.includes(account.accountId)
    );

    if (availableAccounts.length === 0) return null;

    // æ ¹æ®ç­–ç•¥é€‰æ‹©è´¦å·
    switch (pool.strategy) {
      case 'round_robin':
        return this.roundRobinSelection(pool.poolId, availableAccounts);
        
      case 'least_connections':
        return this.leastConnectionsSelection(availableAccounts);
        
      case 'weighted':
        return this.weightedSelection(availableAccounts);
        
      case 'health_based':
        return this.healthBasedSelection(availableAccounts);
        
      default:
        return availableAccounts[0];
    }
  }

  /**
   * è½®è¯¢é€‰æ‹©ç®—æ³•
   */
  private roundRobinSelection(
    poolId: string, 
    accounts: EnterpriseServiceRoute[]
  ): EnterpriseServiceRoute {
    const counterKey = `pool_counter:${poolId}`;
    const counter = this.counters.get(counterKey) || 0;
    const selectedAccount = accounts[counter % accounts.length];
    this.counters.set(counterKey, counter + 1);
    return selectedAccount;
  }

  /**
   * æœ€å°‘è¿æ¥é€‰æ‹©ç®—æ³•
   */
  private leastConnectionsSelection(
    accounts: EnterpriseServiceRoute[]
  ): EnterpriseServiceRoute {
    return accounts.reduce((min, current) => 
      current.currentLoad < min.currentLoad ? current : min
    );
  }

  /**
   * åŠ æƒé€‰æ‹©ç®—æ³•
   */
  private weightedSelection(accounts: EnterpriseServiceRoute[]): EnterpriseServiceRoute {
    const totalWeight = accounts.reduce((sum, acc) => sum + acc.weight, 0);
    const randomWeight = Math.random() * totalWeight;
    
    let currentWeight = 0;
    for (const account of accounts) {
      currentWeight += account.weight;
      if (randomWeight <= currentWeight) {
        return account;
      }
    }
    
    return accounts[0];
  }

  /**
   * åŸºäºå¥åº·åˆ†æ•°çš„é€‰æ‹©ç®—æ³•
   */
  private healthBasedSelection(accounts: EnterpriseServiceRoute[]): EnterpriseServiceRoute {
    // æŒ‰å¥åº·åˆ†æ•°å’Œè´Ÿè½½çš„ç»¼åˆè¯„åˆ†æ’åº
    const scored = accounts.map(account => ({
      account,
      score: account.healthScore * 0.7 + (100 - account.currentLoad) * 0.3
    })).sort((a, b) => b.score - a.score);
    
    return scored[0].account;
  }

  /**
   * å®æ—¶è´Ÿè½½ç›‘æ§å’Œæ›´æ–°
   */
  async updateAccountLoad(accountId: string, newLoad: number): Promise<void> {
    this.accountLoads.set(accountId, newLoad);
    
    // æ›´æ–°ç¼“å­˜
    await cacheManager.set(`account:load:${accountId}`, newLoad, 60);
    
    // å¦‚æœè´Ÿè½½è¿‡é«˜ï¼Œè§¦å‘å‘Šè­¦
    if (newLoad > 90) {
      await this.triggerHighLoadAlert(accountId, newLoad);
    }
  }

  /**
   * å¥åº·æ£€æŸ¥å’Œåˆ†æ•°æ›´æ–°
   */
  async updateHealthScore(accountId: string): Promise<void> {
    try {
      const isHealthy = await this.performHealthCheck(accountId);
      const currentScore = this.healthScores.get(accountId) || 100;
      
      let newScore: number;
      if (isHealthy) {
        // å¥åº·æ—¶é€æ¸æ¢å¤åˆ†æ•°
        newScore = Math.min(100, currentScore + 10);
      } else {
        // ä¸å¥åº·æ—¶å¿«é€Ÿé™ä½åˆ†æ•°
        newScore = Math.max(0, currentScore - 30);
      }
      
      this.healthScores.set(accountId, newScore);
      await cacheManager.set(`account:health_score:${accountId}`, newScore, 300);
      
      // åˆ†æ•°è¿‡ä½æ—¶è§¦å‘å‘Šè­¦
      if (newScore < 30) {
        await this.triggerUnhealthyAlert(accountId, newScore);
      }
      
    } catch (error) {
      console.error(`Health check failed for account ${accountId}:`, error);
      this.healthScores.set(accountId, 0);
    }
  }

  /**
   * ä½¿ç”¨é™é¢æ£€æŸ¥
   */
  private async checkPoolUsageLimit(groupId: string, poolId: string): Promise<boolean> {
    const binding = await prisma.groupPoolBinding.findUnique({
      where: {
        groupId_poolId: { groupId, poolId }
      }
    });

    if (!binding) return false;

    const now = new Date();
    const hourKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}-${now.getHours()}`;
    const dayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
    const monthKey = `${now.getFullYear()}-${now.getMonth()}`;

    // æ£€æŸ¥å°æ—¶é™é¢
    if (binding.usageLimitHourly > 0) {
      const hourlyUsage = await cacheManager.get<number>(`pool_usage:${poolId}:${groupId}:${hourKey}`) || 0;
      if (hourlyUsage >= binding.usageLimitHourly) return false;
    }

    // æ£€æŸ¥æ—¥é™é¢
    if (binding.usageLimitDaily > 0) {
      const dailyUsage = await cacheManager.get<number>(`pool_usage:${poolId}:${groupId}:${dayKey}`) || 0;
      if (dailyUsage >= binding.usageLimitDaily) return false;
    }

    // æ£€æŸ¥æœˆé™é¢
    if (binding.usageLimitMonthly > 0) {
      const monthlyUsage = await cacheManager.get<number>(`pool_usage:${poolId}:${groupId}:${monthKey}`) || 0;
      if (monthlyUsage >= binding.usageLimitMonthly) return false;
    }

    return true;
  }

  /**
   * è®°å½•ä½¿ç”¨é‡å¹¶æ›´æ–°é™é¢è®¡æ•°å™¨
   */
  async recordUsage(
    groupId: string, 
    poolId: string, 
    accountId: string, 
    tokens: number
  ): Promise<void> {
    const now = new Date();
    const hourKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}-${now.getHours()}`;
    const dayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
    const monthKey = `${now.getFullYear()}-${now.getMonth()}`;

    // æ›´æ–°å„æ—¶é—´ç»´åº¦çš„ä½¿ç”¨é‡è®¡æ•°å™¨
    const hourUsageKey = `pool_usage:${poolId}:${groupId}:${hourKey}`;
    const dayUsageKey = `pool_usage:${poolId}:${groupId}:${dayKey}`;
    const monthUsageKey = `pool_usage:${poolId}:${groupId}:${monthKey}`;

    const redis = cacheManager.getClient();
    if (redis) {
      await Promise.all([
        redis.incrby(hourUsageKey, tokens),
        redis.expire(hourUsageKey, 3600), // 1å°æ—¶è¿‡æœŸ
        redis.incrby(dayUsageKey, tokens),
        redis.expire(dayUsageKey, 86400), // 1å¤©è¿‡æœŸ
        redis.incrby(monthUsageKey, tokens),
        redis.expire(monthUsageKey, 2592000), // 30å¤©è¿‡æœŸ
      ]);
    }

    // æ›´æ–°è´¦å·è´Ÿè½½
    const currentLoad = await this.getAccountCurrentLoad(accountId);
    await this.updateAccountLoad(accountId, currentLoad);
  }

  // è¾…åŠ©æ–¹æ³•å®ç°
  private async getAccountHealthScore(accountId: string): Promise<number> {
    const cached = await cacheManager.get<number>(`account:health_score:${accountId}`);
    return cached !== null ? cached : 100;
  }

  private async getAccountResponseTime(accountId: string): Promise<number> {
    const cached = await cacheManager.get<number>(`account:response_time:${accountId}`);
    return cached !== null ? cached : 0;
  }

  private async getAccountErrorRate(accountId: string): Promise<number> {
    const cached = await cacheManager.get<number>(`account:error_rate:${accountId}`);
    return cached !== null ? cached : 0;
  }

  private async getAccountCurrentLoad(accountId: string): Promise<number> {
    const cached = await cacheManager.get<number>(`account:load:${accountId}`);
    if (cached !== null) return cached;

    // åŸºäºæœ€è¿‘5åˆ†é’Ÿçš„è¯·æ±‚æ•°è®¡ç®—è´Ÿè½½
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    const recentRequests = await prisma.usageStat.count({
      where: {
        requestTime: { gte: fiveMinutesAgo }
        // éœ€è¦åœ¨UsageStatä¸­æ·»åŠ accountIdå­—æ®µ
      }
    });

    const load = Math.min(100, (recentRequests / 500) * 100); // å‡è®¾500ä¸ºæ»¡è´Ÿè½½
    await cacheManager.set(`account:load:${accountId}`, load, 30);
    return load;
  }

  private async performHealthCheck(accountId: string): Promise<boolean> {
    try {
      const account = await prisma.aiServiceAccount.findUnique({
        where: { id: accountId }
      });

      if (!account || !account.isEnabled || account.status !== 'active') {
        return false;
      }

      // è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„å¥åº·æ£€æŸ¥é€»è¾‘
      // æ¯”å¦‚å‘é€ä¸€ä¸ªç®€å•çš„APIè¯·æ±‚æ¥éªŒè¯è´¦å·å¯ç”¨æ€§
      return true;
      
    } catch (error) {
      console.error(`Health check error for account ${accountId}:`, error);
      return false;
    }
  }

  private hasServiceType(pool: PoolRoutingStrategy, serviceType: string): boolean {
    return pool.accounts.some(account => 
      account.serviceName.includes(serviceType)
    );
  }

  private getPoolPriority(pool: PoolRoutingStrategy): number {
    return Math.min(...pool.accounts.map(acc => acc.priority));
  }

  private async triggerHighLoadAlert(accountId: string, load: number): Promise<void> {
    console.warn(`High load alert: Account ${accountId} at ${load}% load`);
    // å®ç°å‘Šè­¦é€»è¾‘ï¼Œå¦‚å‘é€é‚®ä»¶ã€Slacké€šçŸ¥ç­‰
  }

  private async triggerUnhealthyAlert(accountId: string, score: number): Promise<void> {
    console.warn(`Unhealthy account alert: Account ${accountId} health score: ${score}`);
    // å®ç°å‘Šè­¦é€»è¾‘
  }
}
```

#### 6.2 è´Ÿè½½å‡è¡¡ç­–ç•¥å¯¹æ¯”

| ç­–ç•¥ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|----------|------|------|
| **è½®è¯¢** | è´¦å·æ€§èƒ½ç›¸è¿‘ | ç®€å•ã€å…¬å¹³ | ä¸è€ƒè™‘å®é™…è´Ÿè½½ |
| **æœ€å°‘è¿æ¥** | è´¦å·æ€§èƒ½ä¸åŒ | è€ƒè™‘å®é™…è´Ÿè½½ | è®¡ç®—å¼€é”€è¾ƒå¤§ |
| **åŠ æƒåˆ†é…** | è´¦å·æ€§èƒ½å·®å¼‚å¤§ | çµæ´»é…ç½®æƒé‡ | éœ€è¦æ‰‹åŠ¨è°ƒæ•´æƒé‡ |
| **å¥åº·åˆ†æ•°** | è´¦å·ç¨³å®šæ€§è¦æ±‚é«˜ | è‡ªåŠ¨é¿å¼€é—®é¢˜è´¦å· | å¥åº·æ£€æŸ¥å¼€é”€ |
      
      case 'least_connections':
        return this.leastConnectionsSelection(availableAccounts);
      
      case 'weighted':
        return this.weightedSelection(availableAccounts);
      
      case 'health_based':
        return this.healthBasedSelection(availableAccounts);
      
      default:
        return availableAccounts[0];
    }
  }

  /**
   * è½®è¯¢é€‰æ‹©ç®—æ³•
   */
  private roundRobinSelection(
    poolId: string, 
    accounts: EnterpriseServiceRoute[]
  ): EnterpriseServiceRoute {
    const key = `rr_counter:${poolId}`;
    const counter = this.connections.get(key) || 0;
    const selectedAccount = accounts[counter % accounts.length];
    this.connections.set(key, counter + 1);
    return selectedAccount;
  }

  /**
   * æœ€å°‘è¿æ¥é€‰æ‹©ç®—æ³•
   */
  private leastConnectionsSelection(
    accounts: EnterpriseServiceRoute[]
  ): EnterpriseServiceRoute {
    return accounts.reduce((min, account) => 
      account.currentLoad < min.currentLoad ? account : min
    );
  }

  /**
   * åŠ æƒé€‰æ‹©ç®—æ³•
   */
  private weightedSelection(
    accounts: EnterpriseServiceRoute[]
  ): EnterpriseServiceRoute {
    const totalWeight = accounts.reduce((sum, acc) => sum + acc.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const account of accounts) {
      random -= account.weight;
      if (random <= 0) {
        return account;
      }
    }
    
    return accounts[0]; // fallback
  }

  /**
   * åŸºäºå¥åº·åˆ†æ•°çš„é€‰æ‹©ç®—æ³•
   */
  private healthBasedSelection(
    accounts: EnterpriseServiceRoute[]
  ): EnterpriseServiceRoute {
    // æŒ‰å¥åº·åˆ†æ•°å’Œè´Ÿè½½ç»¼åˆè¯„åˆ†æ’åº
    const scored = accounts.map(account => ({
      account,
      score: account.healthScore * 0.7 + (100 - account.currentLoad) * 0.3
    })).sort((a, b) => b.score - a.score);
    
    return scored[0].account;
  }

  /**
   * è·å–è´¦å·å½“å‰è´Ÿè½½
   */
  private async getAccountCurrentLoad(accountId: string): Promise<number> {
    const cached = await cacheManager.get(`account:load:${accountId}`);
    if (cached) return cached as number;
    
    // å®é™…è´Ÿè½½è®¡ç®—é€»è¾‘
    const load = Math.random() * 100; // æ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…åº”è¯¥ä»ç›‘æ§ç³»ç»Ÿè·å–
    await cacheManager.set(`account:load:${accountId}`, load, 30);
    return load;
  }

  /**
   * è·å–è´¦å·å¥åº·åˆ†æ•°
   */
  private async getAccountHealthScore(accountId: string): Promise<number> {
    const cached = await cacheManager.get(`account:health:${accountId}`);
    if (cached) return cached as number;
    
    // å¥åº·åˆ†æ•°è®¡ç®—é€»è¾‘
    const health = Math.random() * 100; // æ¨¡æ‹Ÿæ•°æ®
    await cacheManager.set(`account:health:${accountId}`, health, 60);
    return health;
  }

  /**
   * æ£€æŸ¥è´¦å·æ± ä½¿ç”¨é™é¢
   */
  private async checkPoolUsageLimit(groupId: string, poolId: string): Promise<boolean> {
    // è·å–ä½¿ç”¨é™é¢é…ç½®
    const binding = await prisma.groupPoolBinding.findFirst({
      where: { groupId, poolId, isActive: true }
    });
    
    if (!binding) return false;
    
    // æ£€æŸ¥å°æ—¶/æ—¥/æœˆé™é¢
    if (binding.usageLimitHourly > 0) {
      const hourlyUsage = await this.getHourlyUsage(groupId, poolId);
      if (hourlyUsage >= binding.usageLimitHourly) return false;
    }
    
    if (binding.usageLimitDaily > 0) {
      const dailyUsage = await this.getDailyUsage(groupId, poolId);
      if (dailyUsage >= binding.usageLimitDaily) return false;
    }
    
    if (binding.usageLimitMonthly > 0) {
      const monthlyUsage = await this.getMonthlyUsage(groupId, poolId);
      if (monthlyUsage >= binding.usageLimitMonthly) return false;
    }
    
    return true;
  }

  // è¾…åŠ©æ–¹æ³•
  private hasServiceType(pool: PoolRoutingStrategy, serviceType: string): boolean {
    return pool.accounts.some(account => 
      account.serviceName.toLowerCase().includes(serviceType.toLowerCase())
    );
  }

  private getPoolPriority(pool: PoolRoutingStrategy): number {
    return pool.accounts[0]?.priority || 999;
  }

  private async getHourlyUsage(groupId: string, poolId: string): Promise<number> {
    // å®é™…åº”è¯¥æŸ¥è¯¢usage_statsè¡¨
    return 0;
  }

  private async getDailyUsage(groupId: string, poolId: string): Promise<number> {
    return 0;
  }

  private async getMonthlyUsage(groupId: string, poolId: string): Promise<number> {
    return 0;
  }

  private async getAccountResponseTime(accountId: string): Promise<number> {
    return Math.random() * 1000; // æ¨¡æ‹Ÿå“åº”æ—¶é—´
  }

  private async getAccountErrorRate(accountId: string): Promise<number> {
    return Math.random() * 10; // æ¨¡æ‹Ÿé”™è¯¯ç‡
  }
}
```

#### 3.2 å¥åº·æ£€æŸ¥æœºåˆ¶
```typescript
class HealthChecker {
  private unhealthyAccounts = new Set<string>();
  
  async checkAccountHealth(account: Account): Promise<boolean> {
    try {
      // å‘é€ç®€å•çš„å¥åº·æ£€æŸ¥è¯·æ±‚
      const response = await account.healthCheck();
      
      if (response.ok) {
        this.unhealthyAccounts.delete(account.id);
        return true;
      } else {
        this.markUnhealthy(account.id);
        return false;
      }
    } catch (error) {
      this.markUnhealthy(account.id);
      return false;
    }
  }
  
  private markUnhealthy(accountId: string): void {
    this.unhealthyAccounts.add(accountId);
    
    // 30ç§’åé‡æ–°æ£€æŸ¥
    setTimeout(() => {
      this.recheckAccount(accountId);
    }, 30000);
  }
}
```

---

## ğŸ“Š ç›‘æ§ä¸å‘Šè­¦

### 1. å®æ—¶ç›‘æ§æŒ‡æ ‡

#### 1.1 ç³»ç»Ÿçº§æŒ‡æ ‡
- **è´¦å·å¯ç”¨æ€§**ï¼šå„AIæœåŠ¡è´¦å·çš„åœ¨çº¿çŠ¶æ€
- **è´Ÿè½½åˆ†å¸ƒ**ï¼šè´¦å·é—´çš„è´Ÿè½½å‡è¡¡æƒ…å†µ  
- **å“åº”æ—¶é—´**ï¼šAIæœåŠ¡çš„å¹³å‡å“åº”æ—¶é—´
- **é”™è¯¯ç‡**ï¼šè¯·æ±‚å¤±è´¥ç‡å’Œé”™è¯¯ç±»å‹åˆ†å¸ƒ
- **æˆæœ¬è¶‹åŠ¿**ï¼šå®æ—¶æˆæœ¬æ¶ˆè€—å’Œé¢„ç®—ä½¿ç”¨æƒ…å†µ

#### 1.2 ä¸šåŠ¡çº§æŒ‡æ ‡  
- **æ‹¼è½¦ç»„æ´»è·ƒåº¦**ï¼šå„ç»„çš„ä½¿ç”¨é¢‘ç‡å’Œæ´»è·ƒç”¨æˆ·æ•°
- **èµ„æºåˆ©ç”¨ç‡**ï¼šè´¦å·æ± çš„åˆ©ç”¨ç‡å’Œç©ºé—²ç‡
- **é¢„ç®—æ‰§è¡Œ**ï¼šå„éƒ¨é—¨é¢„ç®—çš„æ‰§è¡Œè¿›åº¦
- **ç”¨æˆ·æ»¡æ„åº¦**ï¼šå“åº”æ—¶é—´å’ŒæˆåŠŸç‡çš„ç”¨æˆ·ä½“éªŒæŒ‡æ ‡

### 2. å‘Šè­¦æœºåˆ¶
```yaml
å‘Šè­¦è§„åˆ™:
  è´¦å·ä¸å¯ç”¨:
    è§¦å‘æ¡ä»¶: è´¦å·è¿ç»­3æ¬¡å¥åº·æ£€æŸ¥å¤±è´¥
    å‘Šè­¦çº§åˆ«: é«˜
    é€šçŸ¥å¯¹è±¡: ç³»ç»Ÿç®¡ç†å‘˜
    
  è´Ÿè½½è¿‡é«˜:
    è§¦å‘æ¡ä»¶: è´¦å·è´Ÿè½½ > 90% æŒç»­5åˆ†é’Ÿ
    å‘Šè­¦çº§åˆ«: ä¸­  
    é€šçŸ¥å¯¹è±¡: ä¼ä¸šç®¡ç†å‘˜
    
  é¢„ç®—è¶…æ”¯:
    è§¦å‘æ¡ä»¶: é¢„ç®—ä½¿ç”¨ç‡ > 80%
    å‘Šè­¦çº§åˆ«: ä¸­
    é€šçŸ¥å¯¹è±¡: éƒ¨é—¨ç®¡ç†å‘˜
    
  æˆæœ¬å¼‚å¸¸:
    è§¦å‘æ¡ä»¶: æ—¥æˆæœ¬å¢é•¿ > 50%
    å‘Šè­¦çº§åˆ«: é«˜
    é€šçŸ¥å¯¹è±¡: ä¼ä¸šç®¡ç†å‘˜ + è´¢åŠ¡
```

---

## ğŸ› ï¸ å®æ–½è®¡åˆ’

### Phase 1: åŸºç¡€æ¶æ„é‡æ„ (4-6å‘¨)

#### ç›®æ ‡
å»ºç«‹è´¦å·æ± +æ‹¼è½¦ç»„åŒä½“ç³»çš„åŸºç¡€æ¶æ„

#### ä¸»è¦ä»»åŠ¡
1. **æ•°æ®åº“é‡æ„** (1å‘¨)
   - è®¾è®¡æ–°çš„è¡¨ç»“æ„
   - æ•°æ®è¿ç§»è„šæœ¬
   - å‘åå…¼å®¹å¤„ç†

2. **è´¦å·æ± ç®¡ç†** (2å‘¨)
   - è´¦å·æ± CRUDåŠŸèƒ½
   - è´¦å·ç»‘å®šç®¡ç†
   - åŸºç¡€UIç•Œé¢

3. **ç»‘å®šå…³ç³»** (1-2å‘¨)
   - æ‹¼è½¦ç»„ä¸è´¦å·æ± ç»‘å®š
   - ä½¿ç”¨é™é¢æ§åˆ¶
   - æƒé™éªŒè¯

4. **APIé‡æ„** (1å‘¨)
   - AIä»£ç†æœåŠ¡é€‚é…
   - åˆ†é…é€»è¾‘é›†æˆ
   - æ¥å£æµ‹è¯•

#### éªŒæ”¶æ ‡å‡†
- [ ] æ”¯æŒåˆ›å»ºå…±äº«å’Œä¸“å±è´¦å·æ± 
- [ ] æ‹¼è½¦ç»„å¯ä»¥ç»‘å®šå¤šä¸ªè´¦å·æ± 
- [ ] åŸºæœ¬çš„ä½¿ç”¨é™é¢æ§åˆ¶ç”Ÿæ•ˆ
- [ ] åŸæœ‰åŠŸèƒ½ä¿æŒå…¼å®¹

### Phase 2: æ™ºèƒ½åˆ†é…ä¸è´Ÿè½½å‡è¡¡ (3-4å‘¨)

#### ç›®æ ‡  
å®ç°æ™ºèƒ½çš„è´¦å·åˆ†é…å’Œè´Ÿè½½å‡è¡¡æœºåˆ¶

#### ä¸»è¦ä»»åŠ¡
1. **è´Ÿè½½å‡è¡¡ç®—æ³•** (2å‘¨)
   - è½®è¯¢ã€æœ€å°‘è¿æ¥ã€åŠ æƒåˆ†é…
   - å¥åº·æ£€æŸ¥æœºåˆ¶
   - æ•…éšœè½¬ç§»é€»è¾‘

2. **å®æ—¶ç›‘æ§** (1-2å‘¨)
   - è´¦å·è´Ÿè½½ç›‘æ§
   - æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   - ç›‘æ§é¢æ¿

3. **ä¼˜åŒ–è°ƒåº¦** (1å‘¨)
   - é¢„æµ‹æ€§åˆ†é…
   - åŠ¨æ€é™é¢è°ƒæ•´
   - æ’é˜Ÿæœºåˆ¶

#### éªŒæ”¶æ ‡å‡†
- [ ] è´Ÿè½½å‡è¡¡ç®—æ³•æ­£å¸¸å·¥ä½œ
- [ ] è´¦å·æ•…éšœè‡ªåŠ¨åˆ‡æ¢
- [ ] å®æ—¶ç›‘æ§é¢æ¿å¯ç”¨
- [ ] ç³»ç»Ÿæ€§èƒ½è¾¾åˆ°é¢„æœŸ

### Phase 3: ä¼ä¸šçº§åŠŸèƒ½ (3-4å‘¨)

#### ç›®æ ‡
å®Œå–„ä¼ä¸šçº§ç®¡ç†åŠŸèƒ½å’Œæˆæœ¬æ§åˆ¶

#### ä¸»è¦ä»»åŠ¡
1. **ç»„ç»‡æ¶æ„** (1å‘¨)
   - ä¼ä¸šå’Œéƒ¨é—¨ç®¡ç†
   - å±‚çº§æƒé™æ§åˆ¶
   - æ‰¹é‡ç”¨æˆ·å¯¼å…¥

2. **æˆæœ¬åˆ†æ‘Š** (2å‘¨)
   - ä½¿ç”¨é‡ç²¾ç¡®ç»Ÿè®¡
   - å¤šç»´åº¦æˆæœ¬åˆ†æ‘Š
   - é¢„ç®—ç®¡ç†ç³»ç»Ÿ

3. **æŠ¥è¡¨ç³»ç»Ÿ** (1-2å‘¨)
   - ä¼ä¸šçº§ç»Ÿè®¡æŠ¥è¡¨
   - æˆæœ¬åˆ†æå›¾è¡¨
   - æ•°æ®å¯¼å‡ºåŠŸèƒ½

#### éªŒæ”¶æ ‡å‡†
- [ ] æ”¯æŒä¼ä¸šçº§ç»„ç»‡æ¶æ„
- [ ] æˆæœ¬åˆ†æ‘Šè®¡ç®—å‡†ç¡®
- [ ] æŠ¥è¡¨åŠŸèƒ½å®Œæ•´å¯ç”¨
- [ ] æƒé™æ§åˆ¶ç²¾ç»†åŒ–

### Phase 4: ä¼˜åŒ–ä¸å®Œå–„ (2-3å‘¨)

#### ç›®æ ‡
ç³»ç»Ÿä¼˜åŒ–å’Œç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

#### ä¸»è¦ä»»åŠ¡
1. **æ€§èƒ½ä¼˜åŒ–** (1å‘¨)
   - ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
   - æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
   - æ¥å£å“åº”æ—¶é—´ä¼˜åŒ–

2. **å®‰å…¨åŠ å›º** (1å‘¨)
   - æ•°æ®åŠ å¯†
   - è®¿é—®æ§åˆ¶
   - å®¡è®¡æ—¥å¿—

3. **æ–‡æ¡£å’ŒåŸ¹è®­** (1å‘¨)
   - ç”¨æˆ·ä½¿ç”¨æ‰‹å†Œ
   - ç®¡ç†å‘˜åŸ¹è®­ææ–™  
   - APIæ–‡æ¡£

#### éªŒæ”¶æ ‡å‡†
- [ ] ç³»ç»Ÿæ€§èƒ½æ»¡è¶³ç”Ÿäº§è¦æ±‚
- [ ] å®‰å…¨æªæ–½å®Œå¤‡
- [ ] æ–‡æ¡£å’ŒåŸ¹è®­ææ–™å®Œæ•´

---

## ğŸ”’ é£é™©è¯„ä¼°ä¸åº”å¯¹

### æŠ€æœ¯é£é™©

#### 1. æ•°æ®è¿ç§»é£é™©
**é£é™©ç­‰çº§**: ä¸­
**å½±å“**: å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±æˆ–ä¸šåŠ¡ä¸­æ–­
**åº”å¯¹æªæ–½**:
- åˆ¶å®šè¯¦ç»†çš„è¿ç§»è®¡åˆ’å’Œå›æ»šæ–¹æ¡ˆ
- åœ¨æµ‹è¯•ç¯å¢ƒå……åˆ†éªŒè¯
- åˆ†æ‰¹æ¬¡è¿ç§»ï¼Œé™ä½å½±å“èŒƒå›´
- ä¿ç•™åŸç³»ç»Ÿä½œä¸ºå¤‡ä»½

#### 2. æ€§èƒ½ç“¶é¢ˆé£é™©
**é£é™©ç­‰çº§**: ä¸­  
**å½±å“**: ç³»ç»Ÿå“åº”æ…¢ï¼Œç”¨æˆ·ä½“éªŒå·®
**åº”å¯¹æªæ–½**:
- æ—©æœŸè¿›è¡Œæ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
- è®¾è®¡åˆç†çš„ç¼“å­˜ç­–ç•¥
- ä½¿ç”¨è´Ÿè½½æµ‹è¯•å·¥å…·æ¨¡æ‹Ÿé«˜å¹¶å‘
- å‡†å¤‡æ°´å¹³æ‰©å±•æ–¹æ¡ˆ

#### 3. å¤æ‚åº¦é£é™©
**é£é™©ç­‰çº§**: é«˜
**å½±å“**: å¼€å‘å‘¨æœŸå»¶é•¿ï¼Œç»´æŠ¤å›°éš¾
**åº”å¯¹æªæ–½**:
- é‡‡ç”¨åˆ†é˜¶æ®µå¼€å‘ï¼Œé€æ­¥å¢åŠ å¤æ‚åº¦
- å»ºç«‹å®Œå–„çš„æµ‹è¯•ç”¨ä¾‹
- ä»£ç å®¡æŸ¥å’Œæ¶æ„è¯„å®¡
- å……åˆ†çš„æ–‡æ¡£å’Œæ³¨é‡Š

### ä¸šåŠ¡é£é™©  

#### 1. ç”¨æˆ·æ¥å—åº¦é£é™©
**é£é™©ç­‰çº§**: ä¸­
**å½±å“**: ç”¨æˆ·ä¸æ¥å—æ–°åŠŸèƒ½ï¼Œä½¿ç”¨ç‡ä½
**åº”å¯¹æªæ–½**:
- ä¸æ ¸å¿ƒç”¨æˆ·æ·±åº¦æ²Ÿé€šéœ€æ±‚
- æä¾›å¹³æ»‘çš„è¿ç§»è·¯å¾„
- å‡†å¤‡ç”¨æˆ·åŸ¹è®­å’Œæ”¯æŒ
- æ”¶é›†åé¦ˆæŒç»­æ”¹è¿›

#### 2. ç«äº‰é£é™©
**é£é™©ç­‰çº§**: ä½
**å½±å“**: ç«å“æŠ¢å å¸‚åœºå…ˆæœº
**åº”å¯¹æªæ–½**:  
- å…³æ³¨è¡Œä¸šåŠ¨æ€å’Œç«å“å‘å±•
- å»ºç«‹æŠ€æœ¯å£å’å’Œç”¨æˆ·ç²˜æ€§
- å¿«é€Ÿè¿­ä»£ï¼Œä¿æŒåŠŸèƒ½é¢†å…ˆ
- å»ºç«‹è‰¯å¥½çš„ç”¨æˆ·ç¤¾åŒº

---

## ğŸ“ˆ æˆåŠŸæŒ‡æ ‡ (KPI)

### æŠ€æœ¯æŒ‡æ ‡
- **ç³»ç»Ÿå¯ç”¨æ€§**: â‰¥99.9%
- **APIå“åº”æ—¶é—´**: ï¼œ200ms (P95)
- **è´¦å·åˆ©ç”¨ç‡**: â‰¥85%
- **è´Ÿè½½å‡è¡¡æ•ˆæœ**: æ–¹å·®ï¼œ20%

### ä¸šåŠ¡æŒ‡æ ‡  
- **ç”¨æˆ·å¢é•¿**: ä¼ä¸šç”¨æˆ·æ•°é‡å¢é•¿50%+
- **æˆæœ¬èŠ‚çº¦**: å¹³å‡AIä½¿ç”¨æˆæœ¬é™ä½30%+
- **ç”¨æˆ·æ»¡æ„åº¦**: NPS â‰¥8.0
- **åŠŸèƒ½ä½¿ç”¨ç‡**: æ ¸å¿ƒåŠŸèƒ½ä½¿ç”¨ç‡â‰¥70%

### è¿è¥æŒ‡æ ‡
- **Bugä¿®å¤æ—¶é—´**: ï¼œ24å°æ—¶
- **åŠŸèƒ½äº¤ä»˜å‘¨æœŸ**: å¹³å‡ï¼œ2å‘¨
- **æ–‡æ¡£å®Œæ•´åº¦**: â‰¥90%
- **åŸ¹è®­è¦†ç›–ç‡**: â‰¥95%

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒåˆ›æ–°ç‚¹
1. **åŒä½“ç³»è®¾è®¡**ï¼šè´¦å·æ± ä¸æ‹¼è½¦ç»„åˆ†ç¦»ï¼Œå®ç°çµæ´»çš„èµ„æºç®¡ç†
2. **é€šç”¨åŒ–æ¶æ„**ï¼šåŒæ—¶æ»¡è¶³å°å›¢é˜Ÿå’Œä¼ä¸šçº§éœ€æ±‚
3. **æ™ºèƒ½åˆ†é…**ï¼šåŸºäºè´Ÿè½½å‡è¡¡çš„è‡ªåŠ¨è´¦å·åˆ†é…
4. **ç²¾ç»†åŒ–æ§åˆ¶**ï¼šå¤šç»´åº¦çš„ä½¿ç”¨é™é¢å’Œæƒé™ç®¡ç†

### é¢„æœŸæ”¶ç›Š
- **æˆæœ¬ä¼˜åŒ–**ï¼šé€šè¿‡è´¦å·å…±äº«å’Œè´Ÿè½½å‡è¡¡ï¼Œé¢„è®¡é™ä½30-50%çš„AIä½¿ç”¨æˆæœ¬
- **ç®¡ç†æ•ˆç‡**ï¼šè‡ªåŠ¨åŒ–çš„èµ„æºåˆ†é…å’Œç»Ÿè®¡ï¼Œæå‡50%ä»¥ä¸Šçš„ç®¡ç†æ•ˆç‡  
- **ç”¨æˆ·ä½“éªŒ**ï¼šæ™ºèƒ½åˆ†é…å’Œæ•…éšœè½¬ç§»ï¼Œæä¾›æ›´ç¨³å®šçš„æœåŠ¡ä½“éªŒ
- **ä¸šåŠ¡æ‰©å±•**ï¼šæ”¯æŒä»å°å›¢é˜Ÿåˆ°å¤§ä¼ä¸šçš„è§„æ¨¡æ‰©å±•

### é•¿æœŸè§„åˆ’
- **AIæœåŠ¡æ‰©å±•**ï¼šæ”¯æŒæ›´å¤šAIæœåŠ¡æä¾›å•†
- **æ™ºèƒ½ä¼˜åŒ–**ï¼šåŸºäºæœºå™¨å­¦ä¹ çš„èµ„æºåˆ†é…ä¼˜åŒ–
- **ç”Ÿæ€å»ºè®¾**ï¼šå¼€æ”¾APIï¼Œæ”¯æŒç¬¬ä¸‰æ–¹é›†æˆ
- **å›½é™…åŒ–**ï¼šæ”¯æŒå¤šè¯­è¨€å’Œå¤šåœ°åŒºéƒ¨ç½²

---

## ğŸ”„ å¤šAIæ¨¡å‹æ”¯æŒæ¶æ„

### 1. æ¶æ„æ¦‚è¿°

#### 1.1 è®¾è®¡åŸåˆ™
åŸºäºä¼ä¸šçº§å¼¹æ€§éœ€æ±‚ï¼ŒAiCarpool v2.0 æ”¯æŒå¤šAIæ¨¡å‹æ¶æ„ï¼Œå®ç°æœåŠ¡ç«¯ç»Ÿä¸€ç®¡ç†å’Œé€æ˜åˆ‡æ¢ï¼š

- **æœåŠ¡ç«¯åˆ‡æ¢**ï¼šå®¢æˆ·ç«¯æ— éœ€ä¿®æ”¹ï¼Œæ‰€æœ‰æ¨¡å‹åˆ‡æ¢åœ¨æœåŠ¡ç«¯å®Œæˆ
- **å·®å¼‚åŒ–æ”¯æŒ**ï¼šClaude Code CLIæ”¯æŒå¤šæ¨¡å‹åˆ‡æ¢ï¼ŒGemini CLIå’ŒAmpCode CLIä¿æŒç‹¬ç«‹
- **æ™ºèƒ½æ•…éšœè½¬ç§»**ï¼šä¸»æœåŠ¡æ•…éšœæ—¶è‡ªåŠ¨åˆ‡æ¢å¤‡ç”¨æ¨¡å‹
- **ä¼ä¸šçº§ç®¡æ§**ï¼šæ”¯æŒä¸åŒæ‹¼è½¦ç»„é…ç½®ä¸åŒçš„æ¨¡å‹ç­–ç•¥

#### 1.2 æ”¯æŒæ¨¡å‹èŒƒå›´

**Claude Code CLI**ï¼š
- **åŸç”Ÿæ¨¡å‹**ï¼šClaude 4 Sonnetã€Claude 4 Opus  
- **å¤‡ç”¨æ¨¡å‹**ï¼šKimi K2ã€GLM4.5ã€Qwen3
- **åˆ‡æ¢ç­–ç•¥**ï¼šæ”¯æŒæ‰‹åŠ¨åˆ‡æ¢å’Œæ•…éšœè‡ªåŠ¨è½¬ç§»

**Gemini CLI**ï¼š
- **ç‹¬ç«‹è¿è¡Œ**ï¼šä»…æ”¯æŒGeminiç³»åˆ—æ¨¡å‹
- **æ— åˆ‡æ¢åŠŸèƒ½**ï¼šä¿æŒåŸæœ‰å•ä¸€æ¨¡å‹æ¶æ„

**AmpCode CLI**ï¼š
- **ç‹¬ç«‹è¿è¡Œ**ï¼šä»…æ”¯æŒAmpCodeæœåŠ¡
- **æ— åˆ‡æ¢åŠŸèƒ½**ï¼šä¿æŒåŸæœ‰å•ä¸€æ¨¡å‹æ¶æ„

### 2. æŠ€æœ¯æ¶æ„è®¾è®¡

#### 2.1 å¤šæ¨¡å‹æ¶æ„å›¾

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚ (æ— ä¿®æ”¹)"
        CC[Claude Code CLI]
        GC[Gemini CLI] 
        AC[AmpCode CLI]
    end
    
    subgraph "APIç½‘å…³å±‚"
        AG[API Gateway]
        MR[æ¨¡å‹è·¯ç”±å™¨]
    end
    
    subgraph "æ¨¡å‹ç®¡ç†å±‚"
        subgraph "Claude Code å¤šæ¨¡å‹æ”¯æŒ"
            C4S[Claude 4 Sonnet]
            C4O[Claude 4 Opus]
            K2[Kimi K2]
            GLM[GLM4.5]
            QW[Qwen3]
        end
        
        subgraph "ç‹¬ç«‹æœåŠ¡"
            GM[Gemini Models]
            AM[AmpCode Models]
        end
    end
    
    subgraph "ç®¡ç†æœåŠ¡"
        MS[æ¨¡å‹é…ç½®æœåŠ¡]
        FS[æ•…éšœè½¬ç§»æœåŠ¡]
        HS[å¥åº·æ£€æŸ¥æœåŠ¡]
    end
    
    CC --> AG
    GC --> AG  
    AC --> AG
    
    AG --> MR
    MR --> C4S
    MR --> C4O
    MR --> K2
    MR --> GLM
    MR --> QW
    MR --> GM
    MR --> AM
    
    MS --> MR
    FS --> MR
    HS --> MR
    
    style CC fill:#e3f2fd
    style C4S fill:#fff3e0
    style C4O fill:#fff3e0
    style K2 fill:#ffebee
    style GLM fill:#ffebee
    style QW fill:#ffebee
    style GM fill:#e8f5e8
    style AM fill:#f3e5f5
```

#### 2.2 åŸºäºç°æœ‰Routerçš„æ‰©å±•è®¾è®¡

**æ‰©å±•ç°æœ‰AiServiceRouterç±»**ï¼š

```typescript
// æ‰©å±•ç°æœ‰çš„ServiceRouteæ¥å£
interface EnhancedServiceRoute extends ServiceRoute {
  modelType: 'primary' | 'fallback'; // ä¸»æ¨¡å‹æˆ–å¤‡ç”¨æ¨¡å‹
  modelCategory: 'claude_native' | 'claude_fallback' | 'gemini' | 'ampcode';
  modelName: string; // å…·ä½“æ¨¡å‹åç§°å¦‚ "claude-4-sonnet"
  failoverPriority: number; // æ•…éšœè½¬ç§»ä¼˜å…ˆçº§
  supportedFeatures: string[]; // æ”¯æŒçš„åŠŸèƒ½åˆ—è¡¨
}

// å¤šæ¨¡å‹è·¯ç”±ç­–ç•¥
interface MultiModelRoutingConfig extends RoutingConfig {
  primaryModel: string; // ä¸»æ¨¡å‹æ ‡è¯†
  fallbackModels: string[]; // å¤‡ç”¨æ¨¡å‹åˆ—è¡¨ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åº
  failoverTrigger: 'manual' | 'automatic' | 'hybrid'; // åˆ‡æ¢è§¦å‘æ–¹å¼
  healthCheckThreshold: number; // å¥åº·æ£€æŸ¥é˜ˆå€¼
  failbackEnabled: boolean; // æ˜¯å¦æ”¯æŒæ•…éšœæ¢å¤åˆ‡æ¢
}

// æ‰©å±•AiServiceRouterç±»
export class EnhancedAiServiceRouter extends AiServiceRouter {
  private modelConfigs: Map<string, MultiModelRoutingConfig> = new Map();
  private currentActiveModels: Map<string, string> = new Map(); // groupId -> activeModelId
  
  /**
   * ä¸ºClaude Code CLIåˆå§‹åŒ–å¤šæ¨¡å‹è·¯ç”±
   */
  async initializeMultiModelRoutes(groupId: string): Promise<void> {
    // è·å–ç»„çš„æ¨¡å‹é…ç½®
    const modelConfig = await this.getGroupModelConfig(groupId);
    
    if (modelConfig.serviceType === 'claude_code') {
      // Claude Code CLIæ”¯æŒå¤šæ¨¡å‹
      await this.setupClaudeMultiModel(groupId, modelConfig);
    } else {
      // Gemini CLIå’ŒAmpCode CLIä½¿ç”¨åŸæœ‰é€»è¾‘
      await super.initializeRoutes(groupId);
    }
  }
  
  /**
   * æ™ºèƒ½æ¨¡å‹è·¯ç”±
   */
  async routeToOptimalModel(
    groupId: string,
    request: ChatRequest,
    serviceType: 'claude_code' | 'gemini' | 'ampcode'
  ): Promise<ChatResponse> {
    
    if (serviceType !== 'claude_code') {
      // éClaude CodeæœåŠ¡ä½¿ç”¨åŸæœ‰è·¯ç”±é€»è¾‘
      return await super.routeRequest(groupId, request);
    }
    
    // Claude Code CLIå¤šæ¨¡å‹è·¯ç”±é€»è¾‘
    const activeModel = this.currentActiveModels.get(groupId);
    const modelConfig = this.modelConfigs.get(groupId);
    
    if (!activeModel || !modelConfig) {
      throw new Error('æ¨¡å‹é…ç½®æœªåˆå§‹åŒ–');
    }
    
    try {
      // å°è¯•ä½¿ç”¨å½“å‰æ´»è·ƒæ¨¡å‹
      return await this.sendToModel(groupId, activeModel, request);
      
    } catch (error) {
      // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨æ•…éšœè½¬ç§»
      if (modelConfig.failoverTrigger === 'automatic' || 
          modelConfig.failoverTrigger === 'hybrid') {
        
        console.warn(`ä¸»æ¨¡å‹ ${activeModel} æ•…éšœï¼Œå¼€å§‹æ•…éšœè½¬ç§»:`, error);
        return await this.performFailover(groupId, request, activeModel);
      }
      
      throw error;
    }
  }
  
  /**
   * æ‰§è¡Œæ•…éšœè½¬ç§»
   */
  private async performFailover(
    groupId: string, 
    request: ChatRequest, 
    failedModel: string
  ): Promise<ChatResponse> {
    const modelConfig = this.modelConfigs.get(groupId);
    if (!modelConfig) throw new Error('æ¨¡å‹é…ç½®ä¸å­˜åœ¨');
    
    // è·å–å¯ç”¨çš„å¤‡ç”¨æ¨¡å‹ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
    const availableFallbacks = modelConfig.fallbackModels
      .filter(model => model !== failedModel)
      .sort((a, b) => this.getModelPriority(a) - this.getModelPriority(b));
    
    for (const fallbackModel of availableFallbacks) {
      try {
        console.log(`å°è¯•æ•…éšœè½¬ç§»åˆ°æ¨¡å‹: ${fallbackModel}`);
        
        // æ£€æŸ¥å¤‡ç”¨æ¨¡å‹å¥åº·çŠ¶æ€
        if (await this.checkModelHealth(fallbackModel)) {
          const response = await this.sendToModel(groupId, fallbackModel, request);
          
          // æ›´æ–°å½“å‰æ´»è·ƒæ¨¡å‹
          this.currentActiveModels.set(groupId, fallbackModel);
          
          // è®°å½•æ•…éšœè½¬ç§»äº‹ä»¶
          await this.recordFailoverEvent(groupId, failedModel, fallbackModel);
          
          return response;
        }
      } catch (error) {
        console.warn(`å¤‡ç”¨æ¨¡å‹ ${fallbackModel} ä¹Ÿä¸å¯ç”¨:`, error);
        continue;
      }
    }
    
    throw new Error('æ‰€æœ‰æ¨¡å‹å‡ä¸å¯ç”¨ï¼Œæ•…éšœè½¬ç§»å¤±è´¥');
  }
  
  /**
   * æ‰‹åŠ¨åˆ‡æ¢æ¨¡å‹
   */
  async switchModel(
    groupId: string, 
    targetModel: string,
    reason: 'manual' | 'maintenance' | 'performance'
  ): Promise<boolean> {
    try {
      // éªŒè¯ç›®æ ‡æ¨¡å‹å¯ç”¨æ€§
      if (!(await this.checkModelHealth(targetModel))) {
        throw new Error(`ç›®æ ‡æ¨¡å‹ ${targetModel} ä¸å¥åº·`);
      }
      
      const previousModel = this.currentActiveModels.get(groupId);
      
      // åˆ‡æ¢åˆ°ç›®æ ‡æ¨¡å‹
      this.currentActiveModels.set(groupId, targetModel);
      
      // è®°å½•åˆ‡æ¢äº‹ä»¶
      await this.recordModelSwitch(groupId, previousModel, targetModel, reason);
      
      console.log(`æˆåŠŸåˆ‡æ¢æ¨¡å‹: ${previousModel} -> ${targetModel}`);
      return true;
      
    } catch (error) {
      console.error(`æ¨¡å‹åˆ‡æ¢å¤±è´¥:`, error);
      return false;
    }
  }
  
  /**
   * æ¨¡å‹å¥åº·æ£€æŸ¥
   */
  private async checkModelHealth(modelId: string): Promise<boolean> {
    try {
      const startTime = Date.now();
      
      // å‘é€ç®€å•çš„å¥åº·æ£€æŸ¥è¯·æ±‚
      const testRequest: ChatRequest = {
        messages: [{ role: 'user', content: 'ping' }],
        maxTokens: 10
      };
      
      await this.sendToModel('health_check', modelId, testRequest);
      
      const responseTime = Date.now() - startTime;
      
      // å¥åº·æ£€æŸ¥é€šè¿‡æ¡ä»¶ï¼šå“åº”æ—¶é—´ < 5ç§’
      return responseTime < 5000;
      
    } catch (error) {
      console.warn(`æ¨¡å‹å¥åº·æ£€æŸ¥å¤±è´¥ ${modelId}:`, error);
      return false;
    }
  }
  
  /**
   * è·å–å½“å‰æ´»è·ƒæ¨¡å‹çŠ¶æ€
   */
  getActiveModelStatus(groupId: string): {
    activeModel: string;
    availableModels: string[];
    failoverHistory: any[];
  } {
    const activeModel = this.currentActiveModels.get(groupId) || 'unknown';
    const modelConfig = this.modelConfigs.get(groupId);
    
    return {
      activeModel,
      availableModels: modelConfig ? [
        modelConfig.primaryModel,
        ...modelConfig.fallbackModels
      ] : [],
      failoverHistory: [] // ä»æ•°æ®åº“è·å–
    };
  }
  
  // è¾…åŠ©æ–¹æ³•
  private async getGroupModelConfig(groupId: string): Promise<any> {
    // ä»æ•°æ®åº“è·å–ç»„çš„æ¨¡å‹é…ç½®
    return await prisma.modelConfiguration.findFirst({
      where: { groupId }
    });
  }
  
  private async setupClaudeMultiModel(groupId: string, config: any): Promise<void> {
    // è®¾ç½®Claudeå¤šæ¨¡å‹è·¯ç”±
    this.modelConfigs.set(groupId, {
      strategy: 'priority',
      failoverEnabled: true,
      healthCheckInterval: 60000,
      maxRetries: 3,
      timeout: 30000,
      primaryModel: 'claude-4-sonnet',
      fallbackModels: ['claude-4-opus', 'kimi-k2', 'glm-4.5', 'qwen3'],
      failoverTrigger: 'automatic',
      healthCheckThreshold: 80,
      failbackEnabled: true
    });
    
    // è®¾ç½®åˆå§‹æ´»è·ƒæ¨¡å‹
    this.currentActiveModels.set(groupId, 'claude-4-sonnet');
  }
  
  private async sendToModel(
    groupId: string, 
    modelId: string, 
    request: ChatRequest
  ): Promise<ChatResponse> {
    // æ ¹æ®æ¨¡å‹IDåˆ›å»ºå¯¹åº”çš„æœåŠ¡å®ä¾‹å¹¶å‘é€è¯·æ±‚
    const service = await this.createModelService(modelId);
    return await service.chat(request);
  }
  
  private async createModelService(modelId: string) {
    // æ ¹æ®æ¨¡å‹IDåˆ›å»ºå¯¹åº”çš„AIæœåŠ¡å®ä¾‹
    const modelMap: Record<string, { service: string, config: any }> = {
      'claude-4-sonnet': { 
        service: 'claude', 
        config: { model: 'claude-3.5-sonnet-20241022' }
      },
      'claude-4-opus': { 
        service: 'claude', 
        config: { model: 'claude-3-opus-20240229' }
      },
      'kimi-k2': { 
        service: 'kimi', 
        config: { model: 'moonshot-v1-128k' }
      },
      'glm-4.5': { 
        service: 'zhipu', 
        config: { model: 'glm-4-plus' }
      },
      'qwen3': { 
        service: 'qwen', 
        config: { model: 'qwen-max' }
      }
    };
    
    const modelInfo = modelMap[modelId];
    if (!modelInfo) {
      throw new Error(`ä¸æ”¯æŒçš„æ¨¡å‹: ${modelId}`);
    }
    
    // åˆ›å»ºå¯¹åº”çš„æœåŠ¡å®ä¾‹
    return AIServiceFactory.create(modelInfo.service as SupportedAIService, {
      apiKey: process.env[`${modelInfo.service.toUpperCase()}_API_KEY`] || '',
      baseUrl: this.getServiceBaseUrl(modelInfo.service),
      ...modelInfo.config
    });
  }
  
  private getModelPriority(modelId: string): number {
    const priorities: Record<string, number> = {
      'claude-4-sonnet': 1,
      'claude-4-opus': 2,
      'kimi-k2': 3,
      'glm-4.5': 4,
      'qwen3': 5
    };
    return priorities[modelId] || 999;
  }
  
  private async recordFailoverEvent(
    groupId: string, 
    fromModel: string, 
    toModel: string
  ): Promise<void> {
    await prisma.modelFailoverLog.create({
      data: {
        groupId,
        fromModel,
        toModel,
        reason: 'automatic_failover',
        timestamp: new Date()
      }
    });
  }
  
  private async recordModelSwitch(
    groupId: string, 
    fromModel: string | undefined, 
    toModel: string, 
    reason: string
  ): Promise<void> {
    await prisma.modelFailoverLog.create({
      data: {
        groupId,
        fromModel: fromModel || 'unknown',
        toModel,
        reason,
        timestamp: new Date()
      }
    });
  }
}
```

### 3. æ•°æ®åº“æ‰©å±•è®¾è®¡

#### 3.1 åŸºäºç°æœ‰Prisma Schemaçš„æ‰©å±•

```prisma
// æ¨¡å‹é…ç½®è¡¨ - æ”¯æŒå¤šæ¨¡å‹ç®¡ç†
model ModelConfiguration {
  id              String   @id @default(cuid())
  groupId         String
  serviceType     String   // 'claude_code', 'gemini', 'ampcode'
  primaryModel    String   // ä¸»æ¨¡å‹æ ‡è¯†
  fallbackModels  Json     // å¤‡ç”¨æ¨¡å‹åˆ—è¡¨ ['kimi-k2', 'glm-4.5', 'qwen3']
  failoverTrigger String   @default("automatic") // 'manual', 'automatic', 'hybrid'
  healthThreshold Int      @default(80)
  failbackEnabled Boolean  @default(true)
  isEnabled       Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  group           Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, serviceType])
  @@map("model_configurations")
}

// æ¨¡å‹æ•…éšœè½¬ç§»æ—¥å¿—è¡¨
model ModelFailoverLog {
  id          String   @id @default(cuid())
  groupId     String
  fromModel   String
  toModel     String
  reason      String   // 'automatic_failover', 'manual_switch', 'maintenance'
  success     Boolean  @default(true)
  errorMsg    String?
  responseTime Int?    // åˆ‡æ¢å“åº”æ—¶é—´(ms)
  timestamp   DateTime @default(now())
  
  group       Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  @@index([groupId, timestamp])
  @@map("model_failover_logs")
}

// æ¨¡å‹æ€§èƒ½ç›‘æ§è¡¨
model ModelPerformanceMetric {
  id           String   @id @default(cuid())
  groupId      String?
  modelId      String   // æ¨¡å‹æ ‡è¯†
  metricType   String   // 'response_time', 'success_rate', 'error_rate'
  value        Decimal  @db.Decimal(10, 4)
  timestamp    DateTime @default(now())
  metadata     Json?    // é¢å¤–çš„ç›‘æ§æ•°æ®
  
  group        Group?   @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  @@index([modelId, metricType, timestamp])
  @@map("model_performance_metrics")
}

// æ‰©å±•ç°æœ‰Groupæ¨¡å‹
model Group {
  // ... ç°æœ‰å­—æ®µä¿æŒä¸å˜
  
  // æ–°å¢å¤šæ¨¡å‹æ”¯æŒå…³è”
  modelConfigs    ModelConfiguration[]
  failoverLogs    ModelFailoverLog[]
  performanceMetrics ModelPerformanceMetric[]
}

// æ‰©å±•ç°æœ‰AiServiceAccountæ¨¡å‹ä»¥æ”¯æŒæ¨¡å‹ç±»å‹
model AiServiceAccount {
  // ... ç°æœ‰å­—æ®µä¿æŒä¸å˜
  
  // æ–°å¢å­—æ®µ
  modelId         String?  // å…·ä½“æ¨¡å‹æ ‡è¯†ï¼Œå¦‚ "claude-4-sonnet"
  modelVersion    String?  // æ¨¡å‹ç‰ˆæœ¬
  supportedFeatures Json?  // æ”¯æŒçš„åŠŸèƒ½åˆ—è¡¨
  failoverPriority Int     @default(1) // æ•…éšœè½¬ç§»ä¼˜å…ˆçº§
}
```

### 4. APIæ¥å£æ‰©å±•

#### 4.1 æ¨¡å‹ç®¡ç†API

```typescript
// /api/groups/[groupId]/models/route.ts - æ¨¡å‹é…ç½®ç®¡ç†
export async function GET(request: NextRequest, { params }: { params: { groupId: string } }) {
  const { groupId } = params;
  
  try {
    const modelConfig = await prisma.modelConfiguration.findFirst({
      where: { groupId },
      include: {
        group: {
          select: { name: true, id: true }
        }
      }
    });
    
    return createApiResponse(modelConfig || {
      serviceType: 'claude_code',
      primaryModel: 'claude-4-sonnet',
      fallbackModels: ['claude-4-opus', 'kimi-k2', 'glm-4.5', 'qwen3'],
      failoverTrigger: 'automatic'
    }, true, 200);
    
  } catch (error) {
    return createApiResponse(null, false, 'è·å–æ¨¡å‹é…ç½®å¤±è´¥', 500);
  }
}

export async function POST(request: NextRequest, { params }: { params: { groupId: string } }) {
  const { groupId } = params;
  
  try {
    const body = await request.json();
    const { primaryModel, fallbackModels, failoverTrigger, healthThreshold } = body;
    
    const modelConfig = await prisma.modelConfiguration.upsert({
      where: { groupId_serviceType: { groupId, serviceType: 'claude_code' } },
      update: {
        primaryModel,
        fallbackModels,
        failoverTrigger,
        healthThreshold
      },
      create: {
        groupId,
        serviceType: 'claude_code',
        primaryModel,
        fallbackModels,
        failoverTrigger,
        healthThreshold
      }
    });
    
    return createApiResponse(modelConfig, true, 201);
    
  } catch (error) {
    return createApiResponse(null, false, 'æ›´æ–°æ¨¡å‹é…ç½®å¤±è´¥', 500);
  }
}

// /api/groups/[groupId]/models/switch/route.ts - æ¨¡å‹åˆ‡æ¢
export async function POST(request: NextRequest, { params }: { params: { groupId: string } }) {
  const { groupId } = params;
  
  try {
    const body = await request.json();
    const { targetModel, reason = 'manual' } = body;
    
    // ä½¿ç”¨æ‰©å±•çš„è·¯ç”±å™¨æ‰§è¡Œæ¨¡å‹åˆ‡æ¢
    const router = new EnhancedAiServiceRouter();
    const success = await router.switchModel(groupId, targetModel, reason);
    
    if (success) {
      return createApiResponse({ 
        success: true, 
        activeModel: targetModel,
        switchedAt: new Date().toISOString()
      }, true, 200);
    } else {
      return createApiResponse(null, false, 'æ¨¡å‹åˆ‡æ¢å¤±è´¥', 500);
    }
    
  } catch (error) {
    console.error('Model switch error:', error);
    return createApiResponse(null, false, 'æ¨¡å‹åˆ‡æ¢å¼‚å¸¸', 500);
  }
}

// /api/groups/[groupId]/models/status/route.ts - æ¨¡å‹çŠ¶æ€æŸ¥è¯¢  
export async function GET(request: NextRequest, { params }: { params: { groupId: string } }) {
  const { groupId } = params;
  
  try {
    const router = new EnhancedAiServiceRouter();
    const status = router.getActiveModelStatus(groupId);
    
    // è·å–æœ€è¿‘çš„æ•…éšœè½¬ç§»è®°å½•
    const recentFailovers = await prisma.modelFailoverLog.findMany({
      where: { groupId },
      orderBy: { timestamp: 'desc' },
      take: 10
    });
    
    return createApiResponse({
      ...status,
      failoverHistory: recentFailovers
    }, true, 200);
    
  } catch (error) {
    return createApiResponse(null, false, 'è·å–æ¨¡å‹çŠ¶æ€å¤±è´¥', 500);
  }
}
```

#### 4.2 æ™ºèƒ½è·¯ç”±API

```typescript
// /api/ai-proxy/claude-code/route.ts - Claude Codeä¸“ç”¨ä»£ç†
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { messages, groupId, model, ...options } = body;
    
    // éªŒè¯è¯·æ±‚
    if (!messages || !groupId) {
      return createApiResponse(null, false, 'ç¼ºå°‘å¿…è¦å‚æ•°', 400);
    }
    
    // ä½¿ç”¨å¢å¼ºçš„è·¯ç”±å™¨å¤„ç†è¯·æ±‚
    const router = new EnhancedAiServiceRouter();
    await router.initializeMultiModelRoutes(groupId);
    
    const chatRequest: ChatRequest = {
      messages,
      model, // å¯é€‰ï¼Œå¦‚æœæŒ‡å®šåˆ™ä¼˜å…ˆä½¿ç”¨
      ...options
    };
    
    // æ™ºèƒ½è·¯ç”±åˆ°æœ€ä½³æ¨¡å‹
    const response = await router.routeToOptimalModel(
      groupId,
      chatRequest,
      'claude_code'
    );
    
    return createApiResponse(response, true, 200);
    
  } catch (error) {
    console.error('Claude Code proxy error:', error);
    
    // å¦‚æœæ˜¯æ¨¡å‹åˆ‡æ¢ç›¸å…³é”™è¯¯ï¼Œæä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
    if (error instanceof Error) {
      if (error.message.includes('æ¨¡å‹é…ç½®')) {
        return createApiResponse(null, false, 'æ¨¡å‹é…ç½®å¼‚å¸¸ï¼Œè¯·æ£€æŸ¥è®¾ç½®', 503);
      }
      if (error.message.includes('æ•…éšœè½¬ç§»å¤±è´¥')) {
        return createApiResponse(null, false, 'æ‰€æœ‰æ¨¡å‹ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•', 503);
      }
    }
    
    return createApiResponse(null, false, 'AIæœåŠ¡å¼‚å¸¸', 500);
  }
}
```

### 5. ä¼ä¸šçº§ç®¡ç†åŠŸèƒ½

#### 5.1 æ¨¡å‹é…ç½®ç®¡ç†ç•Œé¢

**ç®¡ç†åå°åŠŸèƒ½**ï¼š
- **æ¨¡å‹é…ç½®é¢æ¿**ï¼šå¯è§†åŒ–é…ç½®ä¸»æ¨¡å‹å’Œå¤‡ç”¨æ¨¡å‹
- **æ•…éšœè½¬ç§»ç­–ç•¥**ï¼šè®¾ç½®è‡ªåŠ¨/æ‰‹åŠ¨åˆ‡æ¢è§„åˆ™
- **å®æ—¶ç›‘æ§é¢æ¿**ï¼šæ˜¾ç¤ºå„æ¨¡å‹å¥åº·çŠ¶æ€å’Œæ€§èƒ½æŒ‡æ ‡
- **åˆ‡æ¢å†å²è®°å½•**ï¼šæŸ¥çœ‹æ¨¡å‹åˆ‡æ¢æ—¥å¿—å’Œç»Ÿè®¡

#### 5.2 æˆæœ¬å’Œæ€§èƒ½åˆ†æ

**å¤šæ¨¡å‹æˆæœ¬ç»Ÿè®¡**ï¼š
```typescript
// å¤šæ¨¡å‹ä½¿ç”¨ç»Ÿè®¡
interface MultiModelUsageStats {
  groupId: string;
  period: string; // 'daily', 'weekly', 'monthly'
  modelBreakdown: {
    modelId: string;
    modelName: string;
    requestCount: number;
    totalTokens: number;
    totalCost: number;
    averageResponseTime: number;
    successRate: number;
  }[];
  totalCost: number;
  failoverCount: number;
  costSavings: number; // ç›¸æ¯”å•ä¸€é«˜ç«¯æ¨¡å‹çš„æˆæœ¬èŠ‚çº¦
}
```

### 6. æ•…éšœè½¬ç§»ç­–ç•¥

#### 6.1 è½¬ç§»è§¦å‘æ¡ä»¶

| è§¦å‘åœºæ™¯ | æ£€æµ‹æ–¹å¼ | è½¬ç§»ç­–ç•¥ |
|----------|----------|----------|
| **APIé”™è¯¯** | HTTPçŠ¶æ€ç  â‰¥ 500 | ç«‹å³è½¬ç§»åˆ°å¤‡ç”¨æ¨¡å‹ |
| **å“åº”è¶…æ—¶** | è¯·æ±‚è¶…æ—¶ > 30ç§’ | ç«‹å³è½¬ç§»å¹¶é™ä½å¥åº·åˆ†æ•° |
| **é…é¢è€—å°½** | 429é”™è¯¯ç  | è½¬ç§»åˆ°é…é¢å……è¶³çš„å¤‡ç”¨æ¨¡å‹ |
| **å¥åº·åˆ†æ•°ä½** | åˆ†æ•° < 60 | é€æ­¥è½¬ç§»ï¼Œé¿å…é›ªå´© |
| **æ‰‹åŠ¨ç»´æŠ¤** | ç®¡ç†å‘˜è§¦å‘ | è®¡åˆ’æ€§åˆ‡æ¢åˆ°æŒ‡å®šæ¨¡å‹ |

#### 6.2 æ•…éšœæ¢å¤æœºåˆ¶

**è‡ªåŠ¨æ•…éšœæ¢å¤**ï¼š
- å®šæœŸæ£€æŸ¥åŸä¸»æ¨¡å‹å¥åº·çŠ¶æ€
- å¥åº·åˆ†æ•°æ¢å¤åˆ° > 80 æ—¶è‡ªåŠ¨åˆ‡å›
- æ”¯æŒæ¸è¿›å¼æµé‡æ¢å¤ï¼Œé¿å…äºŒæ¬¡æ•…éšœ

### 7. ç›‘æ§ä¸å‘Šè­¦

#### 7.1 å¤šæ¨¡å‹ç›‘æ§æŒ‡æ ‡

```yaml
ç›‘æ§ç»´åº¦:
  æ¨¡å‹å¯ç”¨æ€§:
    - å„æ¨¡å‹å¥åº·æ£€æŸ¥çŠ¶æ€
    - APIå“åº”æˆåŠŸç‡
    - å¹³å‡å“åº”æ—¶é—´
    
  æ•…éšœè½¬ç§»:
    - æ•…éšœè½¬ç§»é¢‘ç‡
    - æ•…éšœè½¬ç§»æˆåŠŸç‡  
    - æ•…éšœæ¢å¤æ—¶é—´
    
  æˆæœ¬æ•ˆç›Š:
    - å„æ¨¡å‹ä½¿ç”¨åˆ†å¸ƒ
    - æˆæœ¬å¯¹æ¯”åˆ†æ
    - æ€§ä»·æ¯”è¯„ä¼°
    
  ç”¨æˆ·ä½“éªŒ:
    - è¯·æ±‚å¤„ç†æ—¶å»¶
    - æœåŠ¡è¿ç»­æ€§
    - é”™è¯¯ç‡ç»Ÿè®¡
```

#### 7.2 æ™ºèƒ½å‘Šè­¦è§„åˆ™

```yaml
å‘Šè­¦è§„åˆ™:
  ä¸»æ¨¡å‹æ•…éšœ:
    æ¡ä»¶: ä¸»æ¨¡å‹è¿ç»­3æ¬¡å¥åº·æ£€æŸ¥å¤±è´¥
    çº§åˆ«: é«˜
    åŠ¨ä½œ: ç«‹å³æ•…éšœè½¬ç§» + é€šçŸ¥ç®¡ç†å‘˜
    
  å¤‡ç”¨æ¨¡å‹è€—å°½:
    æ¡ä»¶: å¯ç”¨å¤‡ç”¨æ¨¡å‹ < 2ä¸ª
    çº§åˆ«: é«˜  
    åŠ¨ä½œ: ç´§æ€¥é€šçŸ¥ + æš‚åœæ–°è¯·æ±‚
    
  æˆæœ¬å¼‚å¸¸:
    æ¡ä»¶: æ—¥æˆæœ¬è¶…è¿‡é¢„ç®—20%
    çº§åˆ«: ä¸­
    åŠ¨ä½œ: é€šçŸ¥è´¢åŠ¡ + è‡ªåŠ¨é™çº§æ¨¡å‹
```

### 8. å®æ–½ä¼˜åŠ¿

#### 8.1 ä¸šåŠ¡è¿ç»­æ€§
- **é›¶ä¸­æ–­åˆ‡æ¢**ï¼šæœåŠ¡ç«¯é€æ˜åˆ‡æ¢ï¼Œç”¨æˆ·æ„ŸçŸ¥ä¸åˆ°
- **æ™ºèƒ½æ•…éšœè½¬ç§»**ï¼šè‡ªåŠ¨æ£€æµ‹å¹¶åˆ‡æ¢åˆ°æœ€ä½³å¤‡ç”¨æ¨¡å‹
- **å¤šé‡ä¿éšœ**ï¼šå¤šä¸ªå¤‡ç”¨æ¨¡å‹ç¡®ä¿æœåŠ¡é«˜å¯ç”¨

#### 8.2 æˆæœ¬ä¼˜åŒ–
- **å¼¹æ€§é…ç½®**ï¼šæ ¹æ®è´Ÿè½½å’Œæˆæœ¬åŠ¨æ€é€‰æ‹©æ¨¡å‹
- **æˆæœ¬å¯è§†åŒ–**ï¼šå®æ—¶ç›‘æ§å„æ¨¡å‹æˆæœ¬å’Œæ€§ä»·æ¯”
- **é¢„ç®—æ§åˆ¶**ï¼šè¶…é¢„ç®—æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°ä½æˆæœ¬æ¨¡å‹

#### 8.3 ç®¡ç†ç®€åŒ–
- **ç»Ÿä¸€é…ç½®**ï¼šç®¡ç†åå°ä¸€é”®é…ç½®æ‰€æœ‰æ¨¡å‹ç­–ç•¥
- **è‡ªåŠ¨åŒ–è¿ç»´**ï¼šå‡å°‘æ‰‹åŠ¨å¹²é¢„ï¼Œæå‡è¿ç»´æ•ˆç‡
- **æ•°æ®é©±åŠ¨**ï¼šåŸºäºæ€§èƒ½å’Œæˆæœ¬æ•°æ®ä¼˜åŒ–æ¨¡å‹é€‰æ‹©

---

*æœ¬PRDæ–‡æ¡£å°†æ ¹æ®å¼€å‘è¿›å±•å’Œç”¨æˆ·åé¦ˆæŒç»­æ›´æ–°*